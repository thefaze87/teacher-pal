import {
  Router,
  _extends,
  _inheritsLoose,
  _objectWithoutPropertiesLoose,
  createBrowserHistory,
  createHashHistory,
  createLocation,
  createMemoryHistory,
  createPath,
  invariant,
  locationsAreEqual,
  matchPath,
  require_hoist_non_react_statics_cjs,
  require_path_to_regexp,
  require_prop_types,
  require_react_is,
  tiny_warning_esm_default,
  withRouter
} from "./chunk-XA6FCYWR.js";
import {
  IonRoute,
  LocationHistory,
  NavManager,
  RouteManagerContext,
  StackContext,
  ViewLifeCycleManager,
  ViewStacks,
  __rest,
  generateId,
  getConfig
} from "./chunk-D74GHDG3.js";
import "./chunk-M4X77M43.js";
import "./chunk-CY4DBI7G.js";
import "./chunk-L5P4WHJX.js";
import "./chunk-R5FSY2DH.js";
import "./chunk-YFZMUPPP.js";
import "./chunk-N5VIE3Y5.js";
import "./chunk-FLGAI7SZ.js";
import "./chunk-OY2CTPGU.js";
import "./chunk-Z3GXY5ZN.js";
import "./chunk-YVQRFQRN.js";
import "./chunk-3AQ67Y26.js";
import "./chunk-OPD37YTS.js";
import {
  require_react
} from "./chunk-AOZ5QEK7.js";
import {
  __toESM
} from "./chunk-UXIASGQL.js";

// node_modules/@ionic/react-router/dist/index.esm.js
var import_react2 = __toESM(require_react());

// node_modules/react-router/esm/react-router.js
var import_react = __toESM(require_react());
var import_prop_types = __toESM(require_prop_types());
var import_path_to_regexp = __toESM(require_path_to_regexp());
var import_react_is = __toESM(require_react_is());
var import_hoist_non_react_statics = __toESM(require_hoist_non_react_statics_cjs());
var MAX_SIGNED_31_BIT_INT = 1073741823;
var commonjsGlobal = typeof globalThis !== "undefined" ? (
  // eslint-disable-next-line no-undef
  globalThis
) : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : {};
function getUniqueId() {
  var key = "__global_unique_id__";
  return commonjsGlobal[key] = (commonjsGlobal[key] || 0) + 1;
}
function objectIs(x, y) {
  if (x === y) {
    return x !== 0 || 1 / x === 1 / y;
  } else {
    return x !== x && y !== y;
  }
}
function createEventEmitter(value) {
  var handlers = [];
  return {
    on: function on(handler) {
      handlers.push(handler);
    },
    off: function off(handler) {
      handlers = handlers.filter(function(h) {
        return h !== handler;
      });
    },
    get: function get() {
      return value;
    },
    set: function set(newValue, changedBits) {
      value = newValue;
      handlers.forEach(function(handler) {
        return handler(value, changedBits);
      });
    }
  };
}
function onlyChild(children) {
  return Array.isArray(children) ? children[0] : children;
}
function createReactContext(defaultValue, calculateChangedBits) {
  var _Provider$childContex, _Consumer$contextType;
  var contextProp = "__create-react-context-" + getUniqueId() + "__";
  var Provider = function(_React$Component) {
    _inheritsLoose(Provider2, _React$Component);
    function Provider2() {
      var _this;
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      _this = _React$Component.call.apply(_React$Component, [this].concat(args)) || this;
      _this.emitter = createEventEmitter(_this.props.value);
      return _this;
    }
    var _proto = Provider2.prototype;
    _proto.getChildContext = function getChildContext() {
      var _ref;
      return _ref = {}, _ref[contextProp] = this.emitter, _ref;
    };
    _proto.componentWillReceiveProps = function componentWillReceiveProps(nextProps) {
      if (this.props.value !== nextProps.value) {
        var oldValue = this.props.value;
        var newValue = nextProps.value;
        var changedBits;
        if (objectIs(oldValue, newValue)) {
          changedBits = 0;
        } else {
          changedBits = typeof calculateChangedBits === "function" ? calculateChangedBits(oldValue, newValue) : MAX_SIGNED_31_BIT_INT;
          if (true) {
            true ? tiny_warning_esm_default((changedBits & MAX_SIGNED_31_BIT_INT) === changedBits, "calculateChangedBits: Expected the return value to be a 31-bit integer. Instead received: " + changedBits) : void 0;
          }
          changedBits |= 0;
          if (changedBits !== 0) {
            this.emitter.set(nextProps.value, changedBits);
          }
        }
      }
    };
    _proto.render = function render() {
      return this.props.children;
    };
    return Provider2;
  }(import_react.default.Component);
  Provider.childContextTypes = (_Provider$childContex = {}, _Provider$childContex[contextProp] = import_prop_types.default.object.isRequired, _Provider$childContex);
  var Consumer = function(_React$Component2) {
    _inheritsLoose(Consumer2, _React$Component2);
    function Consumer2() {
      var _this2;
      for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
        args[_key2] = arguments[_key2];
      }
      _this2 = _React$Component2.call.apply(_React$Component2, [this].concat(args)) || this;
      _this2.observedBits = void 0;
      _this2.state = {
        value: _this2.getValue()
      };
      _this2.onUpdate = function(newValue, changedBits) {
        var observedBits = _this2.observedBits | 0;
        if ((observedBits & changedBits) !== 0) {
          _this2.setState({
            value: _this2.getValue()
          });
        }
      };
      return _this2;
    }
    var _proto2 = Consumer2.prototype;
    _proto2.componentWillReceiveProps = function componentWillReceiveProps(nextProps) {
      var observedBits = nextProps.observedBits;
      this.observedBits = observedBits === void 0 || observedBits === null ? MAX_SIGNED_31_BIT_INT : observedBits;
    };
    _proto2.componentDidMount = function componentDidMount() {
      if (this.context[contextProp]) {
        this.context[contextProp].on(this.onUpdate);
      }
      var observedBits = this.props.observedBits;
      this.observedBits = observedBits === void 0 || observedBits === null ? MAX_SIGNED_31_BIT_INT : observedBits;
    };
    _proto2.componentWillUnmount = function componentWillUnmount() {
      if (this.context[contextProp]) {
        this.context[contextProp].off(this.onUpdate);
      }
    };
    _proto2.getValue = function getValue() {
      if (this.context[contextProp]) {
        return this.context[contextProp].get();
      } else {
        return defaultValue;
      }
    };
    _proto2.render = function render() {
      return onlyChild(this.props.children)(this.state.value);
    };
    return Consumer2;
  }(import_react.default.Component);
  Consumer.contextTypes = (_Consumer$contextType = {}, _Consumer$contextType[contextProp] = import_prop_types.default.object, _Consumer$contextType);
  return {
    Provider,
    Consumer
  };
}
var createContext = import_react.default.createContext || createReactContext;
var createNamedContext = function createNamedContext2(name) {
  var context2 = createContext();
  context2.displayName = name;
  return context2;
};
var historyContext = createNamedContext("Router-History");
var context = createNamedContext("Router");
var Router2 = function(_React$Component) {
  _inheritsLoose(Router3, _React$Component);
  Router3.computeRootMatch = function computeRootMatch(pathname) {
    return {
      path: "/",
      url: "/",
      params: {},
      isExact: pathname === "/"
    };
  };
  function Router3(props) {
    var _this;
    _this = _React$Component.call(this, props) || this;
    _this.state = {
      location: props.history.location
    };
    _this._isMounted = false;
    _this._pendingLocation = null;
    if (!props.staticContext) {
      _this.unlisten = props.history.listen(function(location) {
        _this._pendingLocation = location;
      });
    }
    return _this;
  }
  var _proto = Router3.prototype;
  _proto.componentDidMount = function componentDidMount() {
    var _this2 = this;
    this._isMounted = true;
    if (this.unlisten) {
      this.unlisten();
    }
    if (!this.props.staticContext) {
      this.unlisten = this.props.history.listen(function(location) {
        if (_this2._isMounted) {
          _this2.setState({
            location
          });
        }
      });
    }
    if (this._pendingLocation) {
      this.setState({
        location: this._pendingLocation
      });
    }
  };
  _proto.componentWillUnmount = function componentWillUnmount() {
    if (this.unlisten) {
      this.unlisten();
      this._isMounted = false;
      this._pendingLocation = null;
    }
  };
  _proto.render = function render() {
    return import_react.default.createElement(context.Provider, {
      value: {
        history: this.props.history,
        location: this.state.location,
        match: Router3.computeRootMatch(this.state.location.pathname),
        staticContext: this.props.staticContext
      }
    }, import_react.default.createElement(historyContext.Provider, {
      children: this.props.children || null,
      value: this.props.history
    }));
  };
  return Router3;
}(import_react.default.Component);
if (true) {
  Router2.propTypes = {
    children: import_prop_types.default.node,
    history: import_prop_types.default.object.isRequired,
    staticContext: import_prop_types.default.object
  };
  Router2.prototype.componentDidUpdate = function(prevProps) {
    true ? tiny_warning_esm_default(prevProps.history === this.props.history, "You cannot change <Router history>") : void 0;
  };
}
var MemoryRouter = function(_React$Component) {
  _inheritsLoose(MemoryRouter2, _React$Component);
  function MemoryRouter2() {
    var _this;
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _React$Component.call.apply(_React$Component, [this].concat(args)) || this;
    _this.history = createMemoryHistory(_this.props);
    return _this;
  }
  var _proto = MemoryRouter2.prototype;
  _proto.render = function render() {
    return import_react.default.createElement(Router2, {
      history: this.history,
      children: this.props.children
    });
  };
  return MemoryRouter2;
}(import_react.default.Component);
if (true) {
  MemoryRouter.propTypes = {
    initialEntries: import_prop_types.default.array,
    initialIndex: import_prop_types.default.number,
    getUserConfirmation: import_prop_types.default.func,
    keyLength: import_prop_types.default.number,
    children: import_prop_types.default.node
  };
  MemoryRouter.prototype.componentDidMount = function() {
    true ? tiny_warning_esm_default(!this.props.history, "<MemoryRouter> ignores the history prop. To use a custom history, use `import { Router }` instead of `import { MemoryRouter as Router }`.") : void 0;
  };
}
var Lifecycle = function(_React$Component) {
  _inheritsLoose(Lifecycle2, _React$Component);
  function Lifecycle2() {
    return _React$Component.apply(this, arguments) || this;
  }
  var _proto = Lifecycle2.prototype;
  _proto.componentDidMount = function componentDidMount() {
    if (this.props.onMount)
      this.props.onMount.call(this, this);
  };
  _proto.componentDidUpdate = function componentDidUpdate(prevProps) {
    if (this.props.onUpdate)
      this.props.onUpdate.call(this, this, prevProps);
  };
  _proto.componentWillUnmount = function componentWillUnmount() {
    if (this.props.onUnmount)
      this.props.onUnmount.call(this, this);
  };
  _proto.render = function render() {
    return null;
  };
  return Lifecycle2;
}(import_react.default.Component);
function Prompt(_ref) {
  var message = _ref.message, _ref$when = _ref.when, when = _ref$when === void 0 ? true : _ref$when;
  return import_react.default.createElement(context.Consumer, null, function(context2) {
    !context2 ? true ? invariant(false, "You should not use <Prompt> outside a <Router>") : invariant(false) : void 0;
    if (!when || context2.staticContext)
      return null;
    var method = context2.history.block;
    return import_react.default.createElement(Lifecycle, {
      onMount: function onMount(self) {
        self.release = method(message);
      },
      onUpdate: function onUpdate(self, prevProps) {
        if (prevProps.message !== message) {
          self.release();
          self.release = method(message);
        }
      },
      onUnmount: function onUnmount(self) {
        self.release();
      },
      message
    });
  });
}
if (true) {
  messageType = import_prop_types.default.oneOfType([import_prop_types.default.func, import_prop_types.default.string]);
  Prompt.propTypes = {
    when: import_prop_types.default.bool,
    message: messageType.isRequired
  };
}
var messageType;
var cache = {};
var cacheLimit = 1e4;
var cacheCount = 0;
function compilePath(path) {
  if (cache[path])
    return cache[path];
  var generator = import_path_to_regexp.default.compile(path);
  if (cacheCount < cacheLimit) {
    cache[path] = generator;
    cacheCount++;
  }
  return generator;
}
function generatePath(path, params) {
  if (path === void 0) {
    path = "/";
  }
  if (params === void 0) {
    params = {};
  }
  return path === "/" ? path : compilePath(path)(params, {
    pretty: true
  });
}
function Redirect(_ref) {
  var computedMatch = _ref.computedMatch, to = _ref.to, _ref$push = _ref.push, push = _ref$push === void 0 ? false : _ref$push;
  return import_react.default.createElement(context.Consumer, null, function(context2) {
    !context2 ? true ? invariant(false, "You should not use <Redirect> outside a <Router>") : invariant(false) : void 0;
    var history = context2.history, staticContext = context2.staticContext;
    var method = push ? history.push : history.replace;
    var location = createLocation(computedMatch ? typeof to === "string" ? generatePath(to, computedMatch.params) : _extends({}, to, {
      pathname: generatePath(to.pathname, computedMatch.params)
    }) : to);
    if (staticContext) {
      method(location);
      return null;
    }
    return import_react.default.createElement(Lifecycle, {
      onMount: function onMount() {
        method(location);
      },
      onUpdate: function onUpdate(self, prevProps) {
        var prevLocation = createLocation(prevProps.to);
        if (!locationsAreEqual(prevLocation, _extends({}, location, {
          key: prevLocation.key
        }))) {
          method(location);
        }
      },
      to
    });
  });
}
if (true) {
  Redirect.propTypes = {
    push: import_prop_types.default.bool,
    from: import_prop_types.default.string,
    to: import_prop_types.default.oneOfType([import_prop_types.default.string, import_prop_types.default.object]).isRequired
  };
}
var cache$1 = {};
var cacheLimit$1 = 1e4;
var cacheCount$1 = 0;
function compilePath$1(path, options) {
  var cacheKey = "" + options.end + options.strict + options.sensitive;
  var pathCache = cache$1[cacheKey] || (cache$1[cacheKey] = {});
  if (pathCache[path])
    return pathCache[path];
  var keys = [];
  var regexp = (0, import_path_to_regexp.default)(path, keys, options);
  var result = {
    regexp,
    keys
  };
  if (cacheCount$1 < cacheLimit$1) {
    pathCache[path] = result;
    cacheCount$1++;
  }
  return result;
}
function matchPath2(pathname, options) {
  if (options === void 0) {
    options = {};
  }
  if (typeof options === "string" || Array.isArray(options)) {
    options = {
      path: options
    };
  }
  var _options = options, path = _options.path, _options$exact = _options.exact, exact = _options$exact === void 0 ? false : _options$exact, _options$strict = _options.strict, strict = _options$strict === void 0 ? false : _options$strict, _options$sensitive = _options.sensitive, sensitive = _options$sensitive === void 0 ? false : _options$sensitive;
  var paths = [].concat(path);
  return paths.reduce(function(matched, path2) {
    if (!path2 && path2 !== "")
      return null;
    if (matched)
      return matched;
    var _compilePath = compilePath$1(path2, {
      end: exact,
      strict,
      sensitive
    }), regexp = _compilePath.regexp, keys = _compilePath.keys;
    var match = regexp.exec(pathname);
    if (!match)
      return null;
    var url = match[0], values = match.slice(1);
    var isExact = pathname === url;
    if (exact && !isExact)
      return null;
    return {
      path: path2,
      // the path used to match
      url: path2 === "/" && url === "" ? "/" : url,
      // the matched portion of the URL
      isExact,
      // whether or not we matched exactly
      params: keys.reduce(function(memo, key, index) {
        memo[key.name] = values[index];
        return memo;
      }, {})
    };
  }, null);
}
function isEmptyChildren(children) {
  return import_react.default.Children.count(children) === 0;
}
function evalChildrenDev(children, props, path) {
  var value = children(props);
  true ? tiny_warning_esm_default(value !== void 0, "You returned `undefined` from the `children` function of " + ("<Route" + (path ? ' path="' + path + '"' : "") + ">, but you ") + "should have returned a React element or `null`") : void 0;
  return value || null;
}
var Route = function(_React$Component) {
  _inheritsLoose(Route2, _React$Component);
  function Route2() {
    return _React$Component.apply(this, arguments) || this;
  }
  var _proto = Route2.prototype;
  _proto.render = function render() {
    var _this = this;
    return import_react.default.createElement(context.Consumer, null, function(context$1) {
      !context$1 ? true ? invariant(false, "You should not use <Route> outside a <Router>") : invariant(false) : void 0;
      var location = _this.props.location || context$1.location;
      var match = _this.props.computedMatch ? _this.props.computedMatch : _this.props.path ? matchPath2(location.pathname, _this.props) : context$1.match;
      var props = _extends({}, context$1, {
        location,
        match
      });
      var _this$props = _this.props, children = _this$props.children, component = _this$props.component, render2 = _this$props.render;
      if (Array.isArray(children) && isEmptyChildren(children)) {
        children = null;
      }
      return import_react.default.createElement(context.Provider, {
        value: props
      }, props.match ? children ? typeof children === "function" ? true ? evalChildrenDev(children, props, _this.props.path) : children(props) : children : component ? import_react.default.createElement(component, props) : render2 ? render2(props) : null : typeof children === "function" ? true ? evalChildrenDev(children, props, _this.props.path) : children(props) : null);
    });
  };
  return Route2;
}(import_react.default.Component);
if (true) {
  Route.propTypes = {
    children: import_prop_types.default.oneOfType([import_prop_types.default.func, import_prop_types.default.node]),
    component: function component(props, propName) {
      if (props[propName] && !(0, import_react_is.isValidElementType)(props[propName])) {
        return new Error("Invalid prop 'component' supplied to 'Route': the prop is not a valid React component");
      }
    },
    exact: import_prop_types.default.bool,
    location: import_prop_types.default.object,
    path: import_prop_types.default.oneOfType([import_prop_types.default.string, import_prop_types.default.arrayOf(import_prop_types.default.string)]),
    render: import_prop_types.default.func,
    sensitive: import_prop_types.default.bool,
    strict: import_prop_types.default.bool
  };
  Route.prototype.componentDidMount = function() {
    true ? tiny_warning_esm_default(!(this.props.children && !isEmptyChildren(this.props.children) && this.props.component), "You should not use <Route component> and <Route children> in the same route; <Route component> will be ignored") : void 0;
    true ? tiny_warning_esm_default(!(this.props.children && !isEmptyChildren(this.props.children) && this.props.render), "You should not use <Route render> and <Route children> in the same route; <Route render> will be ignored") : void 0;
    true ? tiny_warning_esm_default(!(this.props.component && this.props.render), "You should not use <Route component> and <Route render> in the same route; <Route render> will be ignored") : void 0;
  };
  Route.prototype.componentDidUpdate = function(prevProps) {
    true ? tiny_warning_esm_default(!(this.props.location && !prevProps.location), '<Route> elements should not change from uncontrolled to controlled (or vice versa). You initially used no "location" prop and then provided one on a subsequent render.') : void 0;
    true ? tiny_warning_esm_default(!(!this.props.location && prevProps.location), '<Route> elements should not change from controlled to uncontrolled (or vice versa). You provided a "location" prop initially but omitted it on a subsequent render.') : void 0;
  };
}
function addLeadingSlash(path) {
  return path.charAt(0) === "/" ? path : "/" + path;
}
function addBasename(basename, location) {
  if (!basename)
    return location;
  return _extends({}, location, {
    pathname: addLeadingSlash(basename) + location.pathname
  });
}
function stripBasename(basename, location) {
  if (!basename)
    return location;
  var base = addLeadingSlash(basename);
  if (location.pathname.indexOf(base) !== 0)
    return location;
  return _extends({}, location, {
    pathname: location.pathname.substr(base.length)
  });
}
function createURL(location) {
  return typeof location === "string" ? location : createPath(location);
}
function staticHandler(methodName) {
  return function() {
    true ? invariant(false, "You cannot %s with <StaticRouter>", methodName) : invariant(false);
  };
}
function noop() {
}
var StaticRouter = function(_React$Component) {
  _inheritsLoose(StaticRouter2, _React$Component);
  function StaticRouter2() {
    var _this;
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _React$Component.call.apply(_React$Component, [this].concat(args)) || this;
    _this.handlePush = function(location) {
      return _this.navigateTo(location, "PUSH");
    };
    _this.handleReplace = function(location) {
      return _this.navigateTo(location, "REPLACE");
    };
    _this.handleListen = function() {
      return noop;
    };
    _this.handleBlock = function() {
      return noop;
    };
    return _this;
  }
  var _proto = StaticRouter2.prototype;
  _proto.navigateTo = function navigateTo(location, action) {
    var _this$props = this.props, _this$props$basename = _this$props.basename, basename = _this$props$basename === void 0 ? "" : _this$props$basename, _this$props$context = _this$props.context, context2 = _this$props$context === void 0 ? {} : _this$props$context;
    context2.action = action;
    context2.location = addBasename(basename, createLocation(location));
    context2.url = createURL(context2.location);
  };
  _proto.render = function render() {
    var _this$props2 = this.props, _this$props2$basename = _this$props2.basename, basename = _this$props2$basename === void 0 ? "" : _this$props2$basename, _this$props2$context = _this$props2.context, context2 = _this$props2$context === void 0 ? {} : _this$props2$context, _this$props2$location = _this$props2.location, location = _this$props2$location === void 0 ? "/" : _this$props2$location, rest = _objectWithoutPropertiesLoose(_this$props2, ["basename", "context", "location"]);
    var history = {
      createHref: function createHref(path) {
        return addLeadingSlash(basename + createURL(path));
      },
      action: "POP",
      location: stripBasename(basename, createLocation(location)),
      push: this.handlePush,
      replace: this.handleReplace,
      go: staticHandler("go"),
      goBack: staticHandler("goBack"),
      goForward: staticHandler("goForward"),
      listen: this.handleListen,
      block: this.handleBlock
    };
    return import_react.default.createElement(Router2, _extends({}, rest, {
      history,
      staticContext: context2
    }));
  };
  return StaticRouter2;
}(import_react.default.Component);
if (true) {
  StaticRouter.propTypes = {
    basename: import_prop_types.default.string,
    context: import_prop_types.default.object,
    location: import_prop_types.default.oneOfType([import_prop_types.default.string, import_prop_types.default.object])
  };
  StaticRouter.prototype.componentDidMount = function() {
    true ? tiny_warning_esm_default(!this.props.history, "<StaticRouter> ignores the history prop. To use a custom history, use `import { Router }` instead of `import { StaticRouter as Router }`.") : void 0;
  };
}
var Switch = function(_React$Component) {
  _inheritsLoose(Switch2, _React$Component);
  function Switch2() {
    return _React$Component.apply(this, arguments) || this;
  }
  var _proto = Switch2.prototype;
  _proto.render = function render() {
    var _this = this;
    return import_react.default.createElement(context.Consumer, null, function(context2) {
      !context2 ? true ? invariant(false, "You should not use <Switch> outside a <Router>") : invariant(false) : void 0;
      var location = _this.props.location || context2.location;
      var element, match;
      import_react.default.Children.forEach(_this.props.children, function(child) {
        if (match == null && import_react.default.isValidElement(child)) {
          element = child;
          var path = child.props.path || child.props.from;
          match = path ? matchPath2(location.pathname, _extends({}, child.props, {
            path
          })) : context2.match;
        }
      });
      return match ? import_react.default.cloneElement(element, {
        location,
        computedMatch: match
      }) : null;
    });
  };
  return Switch2;
}(import_react.default.Component);
if (true) {
  Switch.propTypes = {
    children: import_prop_types.default.node,
    location: import_prop_types.default.object
  };
  Switch.prototype.componentDidUpdate = function(prevProps) {
    true ? tiny_warning_esm_default(!(this.props.location && !prevProps.location), '<Switch> elements should not change from uncontrolled to controlled (or vice versa). You initially used no "location" prop and then provided one on a subsequent render.') : void 0;
    true ? tiny_warning_esm_default(!(!this.props.location && prevProps.location), '<Switch> elements should not change from controlled to uncontrolled (or vice versa). You provided a "location" prop initially but omitted it on a subsequent render.') : void 0;
  };
}
var useContext = import_react.default.useContext;
if (true) {
  if (typeof window !== "undefined") {
    global$1 = window;
    key = "__react_router_build__";
    buildNames = {
      cjs: "CommonJS",
      esm: "ES modules",
      umd: "UMD"
    };
    if (global$1[key] && global$1[key] !== "esm") {
      initialBuildName = buildNames[global$1[key]];
      secondaryBuildName = buildNames["esm"];
      throw new Error("You are loading the " + secondaryBuildName + " build of React Router " + ("on a page that is already running the " + initialBuildName + " ") + "build, so things won't work right.");
    }
    global$1[key] = "esm";
  }
}
var global$1;
var key;
var buildNames;
var initialBuildName;
var secondaryBuildName;

// node_modules/@ionic/react-router/dist/index.esm.js
var IonRouteInner = class extends import_react2.default.PureComponent {
  render() {
    return import_react2.default.createElement(Route, {
      path: this.props.path,
      exact: this.props.exact,
      render: this.props.render,
      /**
       * `computedMatch` is a private API in react-router v5 that
       * has been removed in v6.
       *
       * This needs to be removed when we support v6.
       *
       * TODO: FW-647
       */
      computedMatch: this.props.computedMatch
    });
  }
};
var ReactRouterViewStack = class extends ViewStacks {
  constructor() {
    super();
    this.createViewItem = this.createViewItem.bind(this);
    this.findViewItemByRouteInfo = this.findViewItemByRouteInfo.bind(this);
    this.findLeavingViewItemByRouteInfo = this.findLeavingViewItemByRouteInfo.bind(this);
    this.getChildrenToRender = this.getChildrenToRender.bind(this);
    this.findViewItemByPathname = this.findViewItemByPathname.bind(this);
  }
  createViewItem(outletId, reactElement, routeInfo, page) {
    const viewItem = {
      id: generateId("viewItem"),
      outletId,
      ionPageElement: page,
      reactElement,
      mount: true,
      ionRoute: false
    };
    const matchProps = {
      exact: reactElement.props.exact,
      path: reactElement.props.path || reactElement.props.from,
      component: reactElement.props.component
    };
    const match = matchPath2(routeInfo.pathname, matchProps);
    if (reactElement.type === IonRoute) {
      viewItem.ionRoute = true;
      viewItem.disableIonPageManagement = reactElement.props.disableIonPageManagement;
    }
    viewItem.routeData = {
      match,
      childProps: reactElement.props
    };
    return viewItem;
  }
  getChildrenToRender(outletId, ionRouterOutlet, routeInfo) {
    const viewItems = this.getViewItemsForOutlet(outletId);
    import_react2.default.Children.forEach(ionRouterOutlet.props.children, (child) => {
      const viewItem = viewItems.find((v) => {
        return matchComponent$1(child, v.routeData.childProps.path || v.routeData.childProps.from);
      });
      if (viewItem) {
        viewItem.reactElement = child;
      }
    });
    const children = viewItems.map((viewItem) => {
      let clonedChild;
      if (viewItem.ionRoute && !viewItem.disableIonPageManagement) {
        clonedChild = import_react2.default.createElement(ViewLifeCycleManager, { key: `view-${viewItem.id}`, mount: viewItem.mount, removeView: () => this.remove(viewItem) }, import_react2.default.cloneElement(viewItem.reactElement, {
          computedMatch: viewItem.routeData.match
        }));
      } else {
        const match = matchComponent$1(viewItem.reactElement, routeInfo.pathname);
        clonedChild = import_react2.default.createElement(ViewLifeCycleManager, { key: `view-${viewItem.id}`, mount: viewItem.mount, removeView: () => this.remove(viewItem) }, import_react2.default.cloneElement(viewItem.reactElement, {
          computedMatch: viewItem.routeData.match
        }));
        if (!match && viewItem.routeData.match) {
          viewItem.routeData.match = void 0;
          viewItem.mount = false;
        }
      }
      return clonedChild;
    });
    return children;
  }
  findViewItemByRouteInfo(routeInfo, outletId, updateMatch) {
    const { viewItem, match } = this.findViewItemByPath(routeInfo.pathname, outletId);
    const shouldUpdateMatch = updateMatch === void 0 || updateMatch === true;
    if (shouldUpdateMatch && viewItem && match) {
      viewItem.routeData.match = match;
    }
    return viewItem;
  }
  findLeavingViewItemByRouteInfo(routeInfo, outletId, mustBeIonRoute = true) {
    const { viewItem } = this.findViewItemByPath(routeInfo.lastPathname, outletId, false, mustBeIonRoute);
    return viewItem;
  }
  findViewItemByPathname(pathname, outletId) {
    const { viewItem } = this.findViewItemByPath(pathname, outletId);
    return viewItem;
  }
  findViewItemByPath(pathname, outletId, forceExact, mustBeIonRoute) {
    let viewItem;
    let match;
    let viewStack;
    if (outletId) {
      viewStack = this.getViewItemsForOutlet(outletId);
      viewStack.some(matchView);
      if (!viewItem) {
        viewStack.some(matchDefaultRoute);
      }
    } else {
      const viewItems = this.getAllViewItems();
      viewItems.some(matchView);
      if (!viewItem) {
        viewItems.some(matchDefaultRoute);
      }
    }
    return { viewItem, match };
    function matchView(v) {
      if (mustBeIonRoute && !v.ionRoute) {
        return false;
      }
      const matchProps = {
        exact: forceExact ? true : v.routeData.childProps.exact,
        path: v.routeData.childProps.path || v.routeData.childProps.from,
        component: v.routeData.childProps.component
      };
      const myMatch = matchPath2(pathname, matchProps);
      if (myMatch) {
        viewItem = v;
        match = myMatch;
        return true;
      }
      return false;
    }
    function matchDefaultRoute(v) {
      if (!v.routeData.childProps.path && !v.routeData.childProps.from) {
        match = {
          path: pathname,
          url: pathname,
          isExact: true,
          params: {}
        };
        viewItem = v;
        return true;
      }
      return false;
    }
  }
};
function matchComponent$1(node, pathname, forceExact) {
  const matchProps = {
    exact: forceExact ? true : node.props.exact,
    path: node.props.path || node.props.from,
    component: node.props.component
  };
  const match = matchPath2(pathname, matchProps);
  return match;
}
function clonePageElement(leavingViewHtml) {
  let html;
  if (typeof leavingViewHtml === "string") {
    html = leavingViewHtml;
  } else {
    html = leavingViewHtml.outerHTML;
  }
  if (document) {
    const newEl = document.createElement("div");
    newEl.innerHTML = html;
    newEl.style.zIndex = "";
    const ionBackButton = newEl.getElementsByTagName("ion-back-button");
    if (ionBackButton[0]) {
      ionBackButton[0].remove();
    }
    return newEl.firstChild;
  }
  return void 0;
}
var isViewVisible = (el) => !el.classList.contains("ion-page-invisible") && !el.classList.contains("ion-page-hidden");
var StackManager = class extends import_react2.default.PureComponent {
  constructor(props) {
    super(props);
    this.stackContextValue = {
      registerIonPage: this.registerIonPage.bind(this),
      isInOutlet: () => true
    };
    this.pendingPageTransition = false;
    this.registerIonPage = this.registerIonPage.bind(this);
    this.transitionPage = this.transitionPage.bind(this);
    this.handlePageTransition = this.handlePageTransition.bind(this);
    this.id = generateId("routerOutlet");
    this.prevProps = void 0;
    this.skipTransition = false;
  }
  componentDidMount() {
    if (this.clearOutletTimeout) {
      clearTimeout(this.clearOutletTimeout);
    }
    if (this.routerOutletElement) {
      this.setupRouterOutlet(this.routerOutletElement);
      this.handlePageTransition(this.props.routeInfo);
    }
  }
  componentDidUpdate(prevProps) {
    const { pathname } = this.props.routeInfo;
    const { pathname: prevPathname } = prevProps.routeInfo;
    if (pathname !== prevPathname) {
      this.prevProps = prevProps;
      this.handlePageTransition(this.props.routeInfo);
    } else if (this.pendingPageTransition) {
      this.handlePageTransition(this.props.routeInfo);
      this.pendingPageTransition = false;
    }
  }
  componentWillUnmount() {
    this.clearOutletTimeout = this.context.clearOutlet(this.id);
  }
  async handlePageTransition(routeInfo) {
    var _a, _b;
    if (!this.routerOutletElement || !this.routerOutletElement.commit) {
      this.pendingPageTransition = true;
    } else {
      let enteringViewItem = this.context.findViewItemByRouteInfo(routeInfo, this.id);
      let leavingViewItem = this.context.findLeavingViewItemByRouteInfo(routeInfo, this.id);
      if (!leavingViewItem && routeInfo.prevRouteLastPathname) {
        leavingViewItem = this.context.findViewItemByPathname(routeInfo.prevRouteLastPathname, this.id);
      }
      if (leavingViewItem) {
        if (routeInfo.routeAction === "replace") {
          leavingViewItem.mount = false;
        } else if (!(routeInfo.routeAction === "push" && routeInfo.routeDirection === "forward")) {
          if (routeInfo.routeDirection !== "none" && enteringViewItem !== leavingViewItem) {
            leavingViewItem.mount = false;
          }
        } else if ((_a = routeInfo.routeOptions) === null || _a === void 0 ? void 0 : _a.unmount) {
          leavingViewItem.mount = false;
        }
      }
      const enteringRoute = matchRoute((_b = this.ionRouterOutlet) === null || _b === void 0 ? void 0 : _b.props.children, routeInfo);
      if (enteringViewItem) {
        enteringViewItem.reactElement = enteringRoute;
      } else if (enteringRoute) {
        enteringViewItem = this.context.createViewItem(this.id, enteringRoute, routeInfo);
        this.context.addViewItem(enteringViewItem);
      }
      if (enteringViewItem && enteringViewItem.ionPageElement) {
        if (enteringViewItem === leavingViewItem) {
          if (enteringViewItem.routeData.match.url !== routeInfo.pathname) {
            return;
          }
        }
        if (!leavingViewItem && this.props.routeInfo.prevRouteLastPathname) {
          leavingViewItem = this.context.findViewItemByPathname(this.props.routeInfo.prevRouteLastPathname, this.id);
        }
        if (isViewVisible(enteringViewItem.ionPageElement) && leavingViewItem !== void 0 && !isViewVisible(leavingViewItem.ionPageElement)) {
          return;
        }
        this.transitionPage(routeInfo, enteringViewItem, leavingViewItem);
      } else if (leavingViewItem && !enteringRoute && !enteringViewItem) {
        if (leavingViewItem.ionPageElement) {
          leavingViewItem.ionPageElement.classList.add("ion-page-hidden");
          leavingViewItem.ionPageElement.setAttribute("aria-hidden", "true");
        }
      }
      this.forceUpdate();
    }
  }
  registerIonPage(page, routeInfo) {
    const foundView = this.context.findViewItemByRouteInfo(routeInfo, this.id);
    if (foundView) {
      const oldPageElement = foundView.ionPageElement;
      foundView.ionPageElement = page;
      foundView.ionRoute = true;
      if (oldPageElement === page) {
        return;
      }
    }
    this.handlePageTransition(routeInfo);
  }
  async setupRouterOutlet(routerOutlet) {
    const canStart = () => {
      const config = getConfig();
      const swipeEnabled = config && config.get("swipeBackEnabled", routerOutlet.mode === "ios");
      if (!swipeEnabled) {
        return false;
      }
      const { routeInfo } = this.props;
      const propsToUse = this.prevProps && this.prevProps.routeInfo.pathname === routeInfo.pushedByRoute ? this.prevProps.routeInfo : { pathname: routeInfo.pushedByRoute || "" };
      const enteringViewItem = this.context.findViewItemByRouteInfo(propsToUse, this.id, false);
      return !!enteringViewItem && /**
       * The root url '/' is treated as
       * the first view item (but is never mounted),
       * so we do not want to swipe back to the
       * root url.
       */
      enteringViewItem.mount && /**
       * When on the first page (whatever view
       * you land on after the root url) it
       * is possible for findViewItemByRouteInfo to
       * return the exact same view you are currently on.
       * Make sure that we are not swiping back to the same
       * instances of a view.
       */
      enteringViewItem.routeData.match.path !== routeInfo.pathname;
    };
    const onStart = async () => {
      const { routeInfo } = this.props;
      const propsToUse = this.prevProps && this.prevProps.routeInfo.pathname === routeInfo.pushedByRoute ? this.prevProps.routeInfo : { pathname: routeInfo.pushedByRoute || "" };
      const enteringViewItem = this.context.findViewItemByRouteInfo(propsToUse, this.id, false);
      const leavingViewItem = this.context.findViewItemByRouteInfo(routeInfo, this.id, false);
      if (enteringViewItem && leavingViewItem) {
        await this.transitionPage(routeInfo, enteringViewItem, leavingViewItem, "back", true);
      }
      return Promise.resolve();
    };
    const onEnd = (shouldContinue) => {
      if (shouldContinue) {
        this.skipTransition = true;
        this.context.goBack();
      } else {
        const { routeInfo } = this.props;
        const propsToUse = this.prevProps && this.prevProps.routeInfo.pathname === routeInfo.pushedByRoute ? this.prevProps.routeInfo : { pathname: routeInfo.pushedByRoute || "" };
        const enteringViewItem = this.context.findViewItemByRouteInfo(propsToUse, this.id, false);
        const leavingViewItem = this.context.findViewItemByRouteInfo(routeInfo, this.id, false);
        if (enteringViewItem !== leavingViewItem && (enteringViewItem === null || enteringViewItem === void 0 ? void 0 : enteringViewItem.ionPageElement) !== void 0) {
          const { ionPageElement } = enteringViewItem;
          ionPageElement.setAttribute("aria-hidden", "true");
          ionPageElement.classList.add("ion-page-hidden");
        }
      }
    };
    routerOutlet.swipeHandler = {
      canStart,
      onStart,
      onEnd
    };
  }
  async transitionPage(routeInfo, enteringViewItem, leavingViewItem, direction, progressAnimation = false) {
    const runCommit = async (enteringEl, leavingEl) => {
      const skipTransition = this.skipTransition;
      if (skipTransition) {
        this.skipTransition = false;
      } else {
        enteringEl.classList.add("ion-page");
        enteringEl.classList.add("ion-page-invisible");
      }
      await routerOutlet.commit(enteringEl, leavingEl, {
        deepWait: true,
        duration: skipTransition || directionToUse === void 0 ? 0 : void 0,
        direction: directionToUse,
        showGoBack: !!routeInfo.pushedByRoute,
        progressAnimation,
        animationBuilder: routeInfo.routeAnimation
      });
    };
    const routerOutlet = this.routerOutletElement;
    const routeInfoFallbackDirection = routeInfo.routeDirection === "none" || routeInfo.routeDirection === "root" ? void 0 : routeInfo.routeDirection;
    const directionToUse = direction !== null && direction !== void 0 ? direction : routeInfoFallbackDirection;
    if (enteringViewItem && enteringViewItem.ionPageElement && this.routerOutletElement) {
      if (leavingViewItem && leavingViewItem.ionPageElement && enteringViewItem === leavingViewItem) {
        const match = matchComponent(leavingViewItem.reactElement, routeInfo.pathname, true);
        if (match) {
          const newLeavingElement = clonePageElement(leavingViewItem.ionPageElement.outerHTML);
          if (newLeavingElement) {
            this.routerOutletElement.appendChild(newLeavingElement);
            await runCommit(enteringViewItem.ionPageElement, newLeavingElement);
            this.routerOutletElement.removeChild(newLeavingElement);
          }
        } else {
          await runCommit(enteringViewItem.ionPageElement, void 0);
        }
      } else {
        await runCommit(enteringViewItem.ionPageElement, leavingViewItem === null || leavingViewItem === void 0 ? void 0 : leavingViewItem.ionPageElement);
        if (leavingViewItem && leavingViewItem.ionPageElement && !progressAnimation) {
          leavingViewItem.ionPageElement.classList.add("ion-page-hidden");
          leavingViewItem.ionPageElement.setAttribute("aria-hidden", "true");
        }
      }
    }
  }
  render() {
    const { children } = this.props;
    const ionRouterOutlet = import_react2.default.Children.only(children);
    this.ionRouterOutlet = ionRouterOutlet;
    const components = this.context.getChildrenToRender(this.id, this.ionRouterOutlet, this.props.routeInfo, () => {
      this.forceUpdate();
    });
    return import_react2.default.createElement(StackContext.Provider, { value: this.stackContextValue }, import_react2.default.cloneElement(ionRouterOutlet, {
      ref: (node) => {
        if (ionRouterOutlet.props.setRef) {
          ionRouterOutlet.props.setRef(node);
        }
        if (ionRouterOutlet.props.forwardedRef) {
          ionRouterOutlet.props.forwardedRef.current = node;
        }
        this.routerOutletElement = node;
        const { ref } = ionRouterOutlet;
        if (typeof ref === "function") {
          ref(node);
        }
      }
    }, components));
  }
  static get contextType() {
    return RouteManagerContext;
  }
};
function matchRoute(node, routeInfo) {
  let matchedNode;
  import_react2.default.Children.forEach(node, (child) => {
    const matchProps = {
      exact: child.props.exact,
      path: child.props.path || child.props.from,
      component: child.props.component
    };
    const match = matchPath(routeInfo.pathname, matchProps);
    if (match) {
      matchedNode = child;
    }
  });
  if (matchedNode) {
    return matchedNode;
  }
  import_react2.default.Children.forEach(node, (child) => {
    if (!(child.props.path || child.props.from)) {
      matchedNode = child;
    }
  });
  return matchedNode;
}
function matchComponent(node, pathname, forceExact) {
  const matchProps = {
    exact: forceExact ? true : node.props.exact,
    path: node.props.path || node.props.from,
    component: node.props.component
  };
  const match = matchPath(pathname, matchProps);
  return match;
}
var IonRouterInner = class extends import_react2.default.PureComponent {
  constructor(props) {
    super(props);
    this.exitViewFromOtherOutletHandlers = [];
    this.locationHistory = new LocationHistory();
    this.viewStack = new ReactRouterViewStack();
    this.routeMangerContextState = {
      canGoBack: () => this.locationHistory.canGoBack(),
      clearOutlet: this.viewStack.clear,
      findViewItemByPathname: this.viewStack.findViewItemByPathname,
      getChildrenToRender: this.viewStack.getChildrenToRender,
      goBack: () => this.handleNavigateBack(),
      createViewItem: this.viewStack.createViewItem,
      findViewItemByRouteInfo: this.viewStack.findViewItemByRouteInfo,
      findLeavingViewItemByRouteInfo: this.viewStack.findLeavingViewItemByRouteInfo,
      addViewItem: this.viewStack.add,
      unMountViewItem: this.viewStack.remove
    };
    const routeInfo = {
      id: generateId("routeInfo"),
      pathname: this.props.location.pathname,
      search: this.props.location.search
    };
    this.locationHistory.add(routeInfo);
    this.handleChangeTab = this.handleChangeTab.bind(this);
    this.handleResetTab = this.handleResetTab.bind(this);
    this.handleNativeBack = this.handleNativeBack.bind(this);
    this.handleNavigate = this.handleNavigate.bind(this);
    this.handleNavigateBack = this.handleNavigateBack.bind(this);
    this.props.registerHistoryListener(this.handleHistoryChange.bind(this));
    this.handleSetCurrentTab = this.handleSetCurrentTab.bind(this);
    this.state = {
      routeInfo
    };
  }
  handleChangeTab(tab, path, routeOptions) {
    if (!path) {
      return;
    }
    const routeInfo = this.locationHistory.getCurrentRouteInfoForTab(tab);
    const [pathname, search] = path.split("?");
    if (routeInfo) {
      this.incomingRouteParams = Object.assign(Object.assign({}, routeInfo), { routeAction: "push", routeDirection: "none" });
      if (routeInfo.pathname === pathname) {
        this.incomingRouteParams.routeOptions = routeOptions;
        this.props.history.push(routeInfo.pathname + (routeInfo.search || ""));
      } else {
        this.incomingRouteParams.pathname = pathname;
        this.incomingRouteParams.search = search ? "?" + search : void 0;
        this.incomingRouteParams.routeOptions = routeOptions;
        this.props.history.push(pathname + (search ? "?" + search : ""));
      }
    } else {
      this.handleNavigate(pathname, "push", "none", void 0, routeOptions, tab);
    }
  }
  handleHistoryChange(location, action) {
    var _a, _b, _c;
    let leavingLocationInfo;
    if (this.incomingRouteParams) {
      if (this.incomingRouteParams.routeAction === "replace") {
        leavingLocationInfo = this.locationHistory.previous();
      } else {
        leavingLocationInfo = this.locationHistory.current();
      }
    } else {
      leavingLocationInfo = this.locationHistory.current();
    }
    const leavingUrl = leavingLocationInfo.pathname + leavingLocationInfo.search;
    if (leavingUrl !== location.pathname) {
      if (!this.incomingRouteParams) {
        if (action === "REPLACE") {
          this.incomingRouteParams = {
            routeAction: "replace",
            routeDirection: "none",
            tab: this.currentTab
          };
        }
        if (action === "POP") {
          const currentRoute = this.locationHistory.current();
          if (currentRoute && currentRoute.pushedByRoute) {
            const prevInfo = this.locationHistory.findLastLocation(currentRoute);
            this.incomingRouteParams = Object.assign(Object.assign({}, prevInfo), { routeAction: "pop", routeDirection: "back" });
          } else {
            this.incomingRouteParams = {
              routeAction: "pop",
              routeDirection: "none",
              tab: this.currentTab
            };
          }
        }
        if (!this.incomingRouteParams) {
          this.incomingRouteParams = {
            routeAction: "push",
            routeDirection: ((_a = location.state) === null || _a === void 0 ? void 0 : _a.direction) || "forward",
            routeOptions: (_b = location.state) === null || _b === void 0 ? void 0 : _b.routerOptions,
            tab: this.currentTab
          };
        }
      }
      let routeInfo;
      if ((_c = this.incomingRouteParams) === null || _c === void 0 ? void 0 : _c.id) {
        routeInfo = Object.assign(Object.assign({}, this.incomingRouteParams), { lastPathname: leavingLocationInfo.pathname });
        this.locationHistory.add(routeInfo);
      } else {
        const isPushed = this.incomingRouteParams.routeAction === "push" && this.incomingRouteParams.routeDirection === "forward";
        routeInfo = Object.assign(Object.assign({ id: generateId("routeInfo") }, this.incomingRouteParams), { lastPathname: leavingLocationInfo.pathname, pathname: location.pathname, search: location.search, params: this.props.match.params, prevRouteLastPathname: leavingLocationInfo.lastPathname });
        if (isPushed) {
          routeInfo.tab = leavingLocationInfo.tab;
          routeInfo.pushedByRoute = leavingLocationInfo.pathname;
        } else if (routeInfo.routeAction === "pop") {
          const r = this.locationHistory.findLastLocation(routeInfo);
          routeInfo.pushedByRoute = r === null || r === void 0 ? void 0 : r.pushedByRoute;
        } else if (routeInfo.routeAction === "push" && routeInfo.tab !== leavingLocationInfo.tab) {
          const lastRoute = this.locationHistory.getCurrentRouteInfoForTab(routeInfo.tab);
          routeInfo.pushedByRoute = lastRoute === null || lastRoute === void 0 ? void 0 : lastRoute.pushedByRoute;
        } else if (routeInfo.routeAction === "replace") {
          const currentRouteInfo = this.locationHistory.current();
          const currentPushedBy = currentRouteInfo === null || currentRouteInfo === void 0 ? void 0 : currentRouteInfo.pushedByRoute;
          const pushedByRoute = currentPushedBy !== void 0 && currentPushedBy !== routeInfo.pathname ? currentPushedBy : routeInfo.pushedByRoute;
          routeInfo.lastPathname = (currentRouteInfo === null || currentRouteInfo === void 0 ? void 0 : currentRouteInfo.pathname) || routeInfo.lastPathname;
          routeInfo.prevRouteLastPathname = currentRouteInfo === null || currentRouteInfo === void 0 ? void 0 : currentRouteInfo.lastPathname;
          routeInfo.pushedByRoute = pushedByRoute;
          routeInfo.routeDirection = (currentRouteInfo === null || currentRouteInfo === void 0 ? void 0 : currentRouteInfo.routeDirection) || routeInfo.routeDirection;
          routeInfo.routeAnimation = (currentRouteInfo === null || currentRouteInfo === void 0 ? void 0 : currentRouteInfo.routeAnimation) || routeInfo.routeAnimation;
        }
        this.locationHistory.add(routeInfo);
      }
      this.setState({
        routeInfo
      });
    }
    this.incomingRouteParams = void 0;
  }
  /**
   * history@4.x uses goBack(), history@5.x uses back()
   * TODO: If support for React Router <=5 is dropped
   * this logic is no longer needed. We can just
   * assume back() is available.
   */
  handleNativeBack() {
    const history = this.props.history;
    const goBack = history.goBack || history.back;
    goBack();
  }
  handleNavigate(path, routeAction, routeDirection, routeAnimation, routeOptions, tab) {
    this.incomingRouteParams = Object.assign(this.incomingRouteParams || {}, {
      routeAction,
      routeDirection,
      routeOptions,
      routeAnimation,
      tab
    });
    if (routeAction === "push") {
      this.props.history.push(path);
    } else {
      this.props.history.replace(path);
    }
  }
  handleNavigateBack(defaultHref = "/", routeAnimation) {
    const config = getConfig();
    defaultHref = defaultHref ? defaultHref : config && config.get("backButtonDefaultHref");
    const routeInfo = this.locationHistory.current();
    if (routeInfo && routeInfo.pushedByRoute) {
      const prevInfo = this.locationHistory.findLastLocation(routeInfo);
      if (prevInfo) {
        this.incomingRouteParams = Object.assign(Object.assign({}, prevInfo), { routeAction: "pop", routeDirection: "back", routeAnimation: routeAnimation || routeInfo.routeAnimation });
        if (routeInfo.lastPathname === routeInfo.pushedByRoute || /**
         * We need to exclude tab switches/tab
         * context changes here because tabbed
         * navigation is not linear, but router.back()
         * will go back in a linear fashion.
         */
        prevInfo.pathname === routeInfo.pushedByRoute && routeInfo.tab === "" && prevInfo.tab === "") {
          const history = this.props.history;
          const goBack = history.goBack || history.back;
          goBack();
        } else {
          this.handleNavigate(prevInfo.pathname + (prevInfo.search || ""), "pop", "back");
        }
      } else {
        this.handleNavigate(defaultHref, "pop", "back");
      }
    } else {
      this.handleNavigate(defaultHref, "pop", "back");
    }
  }
  handleResetTab(tab, originalHref, originalRouteOptions) {
    const routeInfo = this.locationHistory.getFirstRouteInfoForTab(tab);
    if (routeInfo) {
      const newRouteInfo = Object.assign({}, routeInfo);
      newRouteInfo.pathname = originalHref;
      newRouteInfo.routeOptions = originalRouteOptions;
      this.incomingRouteParams = Object.assign(Object.assign({}, newRouteInfo), { routeAction: "pop", routeDirection: "back" });
      this.props.history.push(newRouteInfo.pathname + (newRouteInfo.search || ""));
    }
  }
  handleSetCurrentTab(tab) {
    this.currentTab = tab;
    const ri = Object.assign({}, this.locationHistory.current());
    if (ri.tab !== tab) {
      ri.tab = tab;
      this.locationHistory.update(ri);
    }
  }
  render() {
    return import_react2.default.createElement(
      RouteManagerContext.Provider,
      { value: this.routeMangerContextState },
      import_react2.default.createElement(NavManager, { ionRoute: IonRouteInner, ionRedirect: {}, stackManager: StackManager, routeInfo: this.state.routeInfo, onNativeBack: this.handleNativeBack, onNavigateBack: this.handleNavigateBack, onNavigate: this.handleNavigate, onSetCurrentTab: this.handleSetCurrentTab, onChangeTab: this.handleChangeTab, onResetTab: this.handleResetTab, locationHistory: this.locationHistory }, this.props.children)
    );
  }
};
var IonRouter = withRouter(IonRouterInner);
IonRouter.displayName = "IonRouter";
var IonReactRouter = class extends import_react2.default.Component {
  constructor(props) {
    super(props);
    const { history } = props, rest = __rest(props, ["history"]);
    this.history = history || createBrowserHistory(rest);
    this.history.listen(this.handleHistoryChange.bind(this));
    this.registerHistoryListener = this.registerHistoryListener.bind(this);
  }
  /**
   * history@4.x passes separate location and action
   * params. history@5.x passes location and action
   * together as a single object.
   * TODO: If support for React Router <=5 is dropped
   * this logic is no longer needed. We can just assume
   * a single object with both location and action.
   */
  handleHistoryChange(location, action) {
    const locationValue = location.location || location;
    const actionValue = location.action || action;
    if (this.historyListenHandler) {
      this.historyListenHandler(locationValue, actionValue);
    }
  }
  registerHistoryListener(cb) {
    this.historyListenHandler = cb;
  }
  render() {
    const _a = this.props, { children } = _a, props = __rest(_a, ["children"]);
    return import_react2.default.createElement(
      Router,
      Object.assign({ history: this.history }, props),
      import_react2.default.createElement(IonRouter, { registerHistoryListener: this.registerHistoryListener }, children)
    );
  }
};
var IonReactMemoryRouter = class extends import_react2.default.Component {
  constructor(props) {
    super(props);
    this.history = props.history;
    this.history.listen(this.handleHistoryChange.bind(this));
    this.registerHistoryListener = this.registerHistoryListener.bind(this);
  }
  /**
   * history@4.x passes separate location and action
   * params. history@5.x passes location and action
   * together as a single object.
   * TODO: If support for React Router <=5 is dropped
   * this logic is no longer needed. We can just assume
   * a single object with both location and action.
   */
  handleHistoryChange(location, action) {
    const locationValue = location.location || location;
    const actionValue = location.action || action;
    if (this.historyListenHandler) {
      this.historyListenHandler(locationValue, actionValue);
    }
  }
  registerHistoryListener(cb) {
    this.historyListenHandler = cb;
  }
  render() {
    const _a = this.props, { children } = _a, props = __rest(_a, ["children"]);
    return import_react2.default.createElement(
      Router2,
      Object.assign({}, props),
      import_react2.default.createElement(IonRouter, { registerHistoryListener: this.registerHistoryListener }, children)
    );
  }
};
var IonReactHashRouter = class extends import_react2.default.Component {
  constructor(props) {
    super(props);
    const { history } = props, rest = __rest(props, ["history"]);
    this.history = history || createHashHistory(rest);
    this.history.listen(this.handleHistoryChange.bind(this));
    this.registerHistoryListener = this.registerHistoryListener.bind(this);
  }
  /**
   * history@4.x passes separate location and action
   * params. history@5.x passes location and action
   * together as a single object.
   * TODO: If support for React Router <=5 is dropped
   * this logic is no longer needed. We can just assume
   * a single object with both location and action.
   */
  handleHistoryChange(location, action) {
    const locationValue = location.location || location;
    const actionValue = location.action || action;
    if (this.historyListenHandler) {
      this.historyListenHandler(locationValue, actionValue);
    }
  }
  registerHistoryListener(cb) {
    this.historyListenHandler = cb;
  }
  render() {
    const _a = this.props, { children } = _a, props = __rest(_a, ["children"]);
    return import_react2.default.createElement(
      Router,
      Object.assign({ history: this.history }, props),
      import_react2.default.createElement(IonRouter, { registerHistoryListener: this.registerHistoryListener }, children)
    );
  }
};
export {
  IonReactHashRouter,
  IonReactMemoryRouter,
  IonReactRouter
};
//# sourceMappingURL=@ionic_react-router.js.map
