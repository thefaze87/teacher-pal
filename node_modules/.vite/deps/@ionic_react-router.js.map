{
  "version": 3,
  "sources": ["../../react-router/modules/miniCreateReactContext.js", "../../react-router/modules/createContext.js", "../../react-router/modules/createNamedContext.js", "../../react-router/modules/HistoryContext.js", "../../react-router/modules/RouterContext.js", "../../react-router/modules/Router.js", "../../react-router/modules/MemoryRouter.js", "../../react-router/modules/Lifecycle.js", "../../react-router/modules/Prompt.js", "../../react-router/modules/generatePath.js", "../../react-router/modules/Redirect.js", "../../react-router/modules/matchPath.js", "../../react-router/modules/Route.js", "../../react-router/modules/StaticRouter.js", "../../react-router/modules/Switch.js", "../../react-router/modules/withRouter.js", "../../react-router/modules/hooks.js", "../../react-router/modules/index.js", "../../@ionic/react-router/src/ReactRouter/IonRouteInner.tsx", "../../@ionic/react-router/src/ReactRouter/ReactRouterViewStack.tsx", "../../@ionic/react-router/src/ReactRouter/clonePageElement.ts", "../../@ionic/react-router/src/ReactRouter/StackManager.tsx", "../../@ionic/react-router/src/ReactRouter/IonRouter.tsx", "../../@ionic/react-router/src/ReactRouter/IonReactRouter.tsx", "../../@ionic/react-router/src/ReactRouter/IonReactMemoryRouter.tsx", "../../@ionic/react-router/src/ReactRouter/IonReactHashRouter.tsx"],
  "sourcesContent": ["// MIT License\n// Copyright (c) 2019-present StringEpsilon <StringEpsilon@gmail.com>\n// Copyright (c) 2017-2019 James Kyle <me@thejameskyle.com>\n// https://github.com/StringEpsilon/mini-create-react-context\nimport React from \"react\";\nimport PropTypes from \"prop-types\";\nimport warning from \"tiny-warning\";\n\nconst MAX_SIGNED_31_BIT_INT = 1073741823;\n\nconst commonjsGlobal =\n  typeof globalThis !== \"undefined\" // 'global proper'\n    ? // eslint-disable-next-line no-undef\n      globalThis\n    : typeof window !== \"undefined\"\n    ? window // Browser\n    : typeof global !== \"undefined\"\n    ? global // node.js\n    : {};\n\nfunction getUniqueId() {\n  let key = \"__global_unique_id__\";\n  return (commonjsGlobal[key] = (commonjsGlobal[key] || 0) + 1);\n}\n\n// Inlined Object.is polyfill.\n// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is\nfunction objectIs(x, y) {\n  if (x === y) {\n    return x !== 0 || 1 / x === 1 / y;\n  } else {\n    // eslint-disable-next-line no-self-compare\n    return x !== x && y !== y;\n  }\n}\n\nfunction createEventEmitter(value) {\n  let handlers = [];\n  return {\n    on(handler) {\n      handlers.push(handler);\n    },\n\n    off(handler) {\n      handlers = handlers.filter(h => h !== handler);\n    },\n\n    get() {\n      return value;\n    },\n\n    set(newValue, changedBits) {\n      value = newValue;\n      handlers.forEach(handler => handler(value, changedBits));\n    }\n  };\n}\n\nfunction onlyChild(children) {\n  return Array.isArray(children) ? children[0] : children;\n}\n\nexport default function createReactContext(defaultValue, calculateChangedBits) {\n  const contextProp = \"__create-react-context-\" + getUniqueId() + \"__\";\n\n  class Provider extends React.Component {\n    emitter = createEventEmitter(this.props.value);\n\n    static childContextTypes = {\n      [contextProp]: PropTypes.object.isRequired\n    };\n\n    getChildContext() {\n      return {\n        [contextProp]: this.emitter\n      };\n    }\n\n    componentWillReceiveProps(nextProps) {\n      if (this.props.value !== nextProps.value) {\n        let oldValue = this.props.value;\n        let newValue = nextProps.value;\n        let changedBits;\n\n        if (objectIs(oldValue, newValue)) {\n          changedBits = 0; // No change\n        } else {\n          changedBits =\n            typeof calculateChangedBits === \"function\"\n              ? calculateChangedBits(oldValue, newValue)\n              : MAX_SIGNED_31_BIT_INT;\n          if (process.env.NODE_ENV !== \"production\") {\n            warning(\n              (changedBits & MAX_SIGNED_31_BIT_INT) === changedBits,\n              \"calculateChangedBits: Expected the return value to be a \" +\n                \"31-bit integer. Instead received: \" +\n                changedBits\n            );\n          }\n\n          changedBits |= 0;\n\n          if (changedBits !== 0) {\n            this.emitter.set(nextProps.value, changedBits);\n          }\n        }\n      }\n    }\n\n    render() {\n      return this.props.children;\n    }\n  }\n\n  class Consumer extends React.Component {\n    static contextTypes = {\n      [contextProp]: PropTypes.object\n    };\n\n    observedBits;\n\n    state = {\n      value: this.getValue()\n    };\n\n    componentWillReceiveProps(nextProps) {\n      let { observedBits } = nextProps;\n      this.observedBits =\n        observedBits === undefined || observedBits === null\n          ? MAX_SIGNED_31_BIT_INT // Subscribe to all changes by default\n          : observedBits;\n    }\n\n    componentDidMount() {\n      if (this.context[contextProp]) {\n        this.context[contextProp].on(this.onUpdate);\n      }\n      let { observedBits } = this.props;\n      this.observedBits =\n        observedBits === undefined || observedBits === null\n          ? MAX_SIGNED_31_BIT_INT // Subscribe to all changes by default\n          : observedBits;\n    }\n\n    componentWillUnmount() {\n      if (this.context[contextProp]) {\n        this.context[contextProp].off(this.onUpdate);\n      }\n    }\n\n    getValue() {\n      if (this.context[contextProp]) {\n        return this.context[contextProp].get();\n      } else {\n        return defaultValue;\n      }\n    }\n\n    onUpdate = (newValue, changedBits) => {\n      const observedBits = this.observedBits | 0;\n      if ((observedBits & changedBits) !== 0) {\n        this.setState({ value: this.getValue() });\n      }\n    };\n\n    render() {\n      return onlyChild(this.props.children)(this.state.value);\n    }\n  }\n\n  return {\n    Provider,\n    Consumer\n  };\n}\n", "// MIT License\n// Copyright (c) 2019-present StringEpsilon <StringEpsilon@gmail.com>\n// Copyright (c) 2017-2019 James Kyle <me@thejameskyle.com>\n// https://github.com/StringEpsilon/mini-create-react-context\nimport React from \"react\";\nimport createReactContext from \"./miniCreateReactContext\";\n\nexport default React.createContext || createReactContext;\n", "// TODO: Replace with React.createContext once we can assume React 16+\nimport createContext from \"./createContext\";\n\nconst createNamedContext = name => {\n  const context = createContext();\n  context.displayName = name;\n\n  return context;\n};\n\nexport default createNamedContext;\n", "import createNamedContext from \"./createNamedContext\";\n\nconst historyContext = /*#__PURE__*/ createNamedContext(\"Router-History\");\nexport default historyContext;\n", "import createNamedContext from \"./createNamedContext\";\n\nconst context = /*#__PURE__*/ createNamedContext(\"Router\");\nexport default context;\n", "import React from \"react\";\nimport PropTypes from \"prop-types\";\nimport warning from \"tiny-warning\";\n\nimport HistoryContext from \"./HistoryContext.js\";\nimport RouterContext from \"./RouterContext.js\";\n\n/**\n * The public API for putting history on context.\n */\nclass Router extends React.Component {\n  static computeRootMatch(pathname) {\n    return { path: \"/\", url: \"/\", params: {}, isExact: pathname === \"/\" };\n  }\n\n  constructor(props) {\n    super(props);\n\n    this.state = {\n      location: props.history.location\n    };\n\n    // This is a bit of a hack. We have to start listening for location\n    // changes here in the constructor in case there are any <Redirect>s\n    // on the initial render. If there are, they will replace/push when\n    // they mount and since cDM fires in children before parents, we may\n    // get a new location before the <Router> is mounted.\n    this._isMounted = false;\n    this._pendingLocation = null;\n\n    if (!props.staticContext) {\n      this.unlisten = props.history.listen(location => {\n        this._pendingLocation = location;\n      });\n    }\n  }\n\n  componentDidMount() {\n    this._isMounted = true;\n\n    if (this.unlisten) {\n      // Any pre-mount location changes have been captured at\n      // this point, so unregister the listener.\n      this.unlisten();\n    }\n    if (!this.props.staticContext) {\n      this.unlisten = this.props.history.listen(location => {\n        if (this._isMounted) {\n          this.setState({ location });\n        }\n      });\n    }\n    if (this._pendingLocation) {\n      this.setState({ location: this._pendingLocation });\n    }\n  }\n\n  componentWillUnmount() {\n    if (this.unlisten) {\n      this.unlisten();\n      this._isMounted = false;\n      this._pendingLocation = null;\n    }\n  }\n\n  render() {\n    return (\n      <RouterContext.Provider\n        value={{\n          history: this.props.history,\n          location: this.state.location,\n          match: Router.computeRootMatch(this.state.location.pathname),\n          staticContext: this.props.staticContext\n        }}\n      >\n        <HistoryContext.Provider\n          children={this.props.children || null}\n          value={this.props.history}\n        />\n      </RouterContext.Provider>\n    );\n  }\n}\n\nif (__DEV__) {\n  Router.propTypes = {\n    children: PropTypes.node,\n    history: PropTypes.object.isRequired,\n    staticContext: PropTypes.object\n  };\n\n  Router.prototype.componentDidUpdate = function(prevProps) {\n    warning(\n      prevProps.history === this.props.history,\n      \"You cannot change <Router history>\"\n    );\n  };\n}\n\nexport default Router;\n", "import React from \"react\";\nimport PropTypes from \"prop-types\";\nimport { createMemoryHistory as createHistory } from \"history\";\nimport warning from \"tiny-warning\";\n\nimport Router from \"./Router.js\";\n\n/**\n * The public API for a <Router> that stores location in memory.\n */\nclass MemoryRouter extends React.Component {\n  history = createHistory(this.props);\n\n  render() {\n    return <Router history={this.history} children={this.props.children} />;\n  }\n}\n\nif (__DEV__) {\n  MemoryRouter.propTypes = {\n    initialEntries: PropTypes.array,\n    initialIndex: PropTypes.number,\n    getUserConfirmation: PropTypes.func,\n    keyLength: PropTypes.number,\n    children: PropTypes.node\n  };\n\n  MemoryRouter.prototype.componentDidMount = function() {\n    warning(\n      !this.props.history,\n      \"<MemoryRouter> ignores the history prop. To use a custom history, \" +\n        \"use `import { Router }` instead of `import { MemoryRouter as Router }`.\"\n    );\n  };\n}\n\nexport default MemoryRouter;\n", "import React from \"react\";\n\nclass Lifecycle extends React.Component {\n  componentDidMount() {\n    if (this.props.onMount) this.props.onMount.call(this, this);\n  }\n\n  componentDidUpdate(prevProps) {\n    if (this.props.onUpdate) this.props.onUpdate.call(this, this, prevProps);\n  }\n\n  componentWillUnmount() {\n    if (this.props.onUnmount) this.props.onUnmount.call(this, this);\n  }\n\n  render() {\n    return null;\n  }\n}\n\nexport default Lifecycle;\n", "import React from \"react\";\nimport PropTypes from \"prop-types\";\nimport invariant from \"tiny-invariant\";\n\nimport Lifecycle from \"./Lifecycle.js\";\nimport RouterContext from \"./RouterContext.js\";\n\n/**\n * The public API for prompting the user before navigating away from a screen.\n */\nfunction Prompt({ message, when = true }) {\n  return (\n    <RouterContext.Consumer>\n      {context => {\n        invariant(context, \"You should not use <Prompt> outside a <Router>\");\n\n        if (!when || context.staticContext) return null;\n\n        const method = context.history.block;\n\n        return (\n          <Lifecycle\n            onMount={self => {\n              self.release = method(message);\n            }}\n            onUpdate={(self, prevProps) => {\n              if (prevProps.message !== message) {\n                self.release();\n                self.release = method(message);\n              }\n            }}\n            onUnmount={self => {\n              self.release();\n            }}\n            message={message}\n          />\n        );\n      }}\n    </RouterContext.Consumer>\n  );\n}\n\nif (__DEV__) {\n  const messageType = PropTypes.oneOfType([PropTypes.func, PropTypes.string]);\n\n  Prompt.propTypes = {\n    when: PropTypes.bool,\n    message: messageType.isRequired\n  };\n}\n\nexport default Prompt;\n", "import pathToRegexp from \"path-to-regexp\";\n\nconst cache = {};\nconst cacheLimit = 10000;\nlet cacheCount = 0;\n\nfunction compilePath(path) {\n  if (cache[path]) return cache[path];\n\n  const generator = pathToRegexp.compile(path);\n\n  if (cacheCount < cacheLimit) {\n    cache[path] = generator;\n    cacheCount++;\n  }\n\n  return generator;\n}\n\n/**\n * Public API for generating a URL pathname from a path and parameters.\n */\nfunction generatePath(path = \"/\", params = {}) {\n  return path === \"/\" ? path : compilePath(path)(params, { pretty: true });\n}\n\nexport default generatePath;\n", "import React from \"react\";\nimport PropTypes from \"prop-types\";\nimport { createLocation, locationsAreEqual } from \"history\";\nimport invariant from \"tiny-invariant\";\n\nimport Lifecycle from \"./Lifecycle.js\";\nimport RouterContext from \"./RouterContext.js\";\nimport generatePath from \"./generatePath.js\";\n\n/**\n * The public API for navigating programmatically with a component.\n */\nfunction Redirect({ computedMatch, to, push = false }) {\n  return (\n    <RouterContext.Consumer>\n      {context => {\n        invariant(context, \"You should not use <Redirect> outside a <Router>\");\n\n        const { history, staticContext } = context;\n\n        const method = push ? history.push : history.replace;\n        const location = createLocation(\n          computedMatch\n            ? typeof to === \"string\"\n              ? generatePath(to, computedMatch.params)\n              : {\n                  ...to,\n                  pathname: generatePath(to.pathname, computedMatch.params)\n                }\n            : to\n        );\n\n        // When rendering in a static context,\n        // set the new location immediately.\n        if (staticContext) {\n          method(location);\n          return null;\n        }\n\n        return (\n          <Lifecycle\n            onMount={() => {\n              method(location);\n            }}\n            onUpdate={(self, prevProps) => {\n              const prevLocation = createLocation(prevProps.to);\n              if (\n                !locationsAreEqual(prevLocation, {\n                  ...location,\n                  key: prevLocation.key\n                })\n              ) {\n                method(location);\n              }\n            }}\n            to={to}\n          />\n        );\n      }}\n    </RouterContext.Consumer>\n  );\n}\n\nif (__DEV__) {\n  Redirect.propTypes = {\n    push: PropTypes.bool,\n    from: PropTypes.string,\n    to: PropTypes.oneOfType([PropTypes.string, PropTypes.object]).isRequired\n  };\n}\n\nexport default Redirect;\n", "import pathToRegexp from \"path-to-regexp\";\n\nconst cache = {};\nconst cacheLimit = 10000;\nlet cacheCount = 0;\n\nfunction compilePath(path, options) {\n  const cacheKey = `${options.end}${options.strict}${options.sensitive}`;\n  const pathCache = cache[cacheKey] || (cache[cacheKey] = {});\n\n  if (pathCache[path]) return pathCache[path];\n\n  const keys = [];\n  const regexp = pathToRegexp(path, keys, options);\n  const result = { regexp, keys };\n\n  if (cacheCount < cacheLimit) {\n    pathCache[path] = result;\n    cacheCount++;\n  }\n\n  return result;\n}\n\n/**\n * Public API for matching a URL pathname to a path.\n */\nfunction matchPath(pathname, options = {}) {\n  if (typeof options === \"string\" || Array.isArray(options)) {\n    options = { path: options };\n  }\n\n  const { path, exact = false, strict = false, sensitive = false } = options;\n\n  const paths = [].concat(path);\n\n  return paths.reduce((matched, path) => {\n    if (!path && path !== \"\") return null;\n    if (matched) return matched;\n\n    const { regexp, keys } = compilePath(path, {\n      end: exact,\n      strict,\n      sensitive\n    });\n    const match = regexp.exec(pathname);\n\n    if (!match) return null;\n\n    const [url, ...values] = match;\n    const isExact = pathname === url;\n\n    if (exact && !isExact) return null;\n\n    return {\n      path, // the path used to match\n      url: path === \"/\" && url === \"\" ? \"/\" : url, // the matched portion of the URL\n      isExact, // whether or not we matched exactly\n      params: keys.reduce((memo, key, index) => {\n        memo[key.name] = values[index];\n        return memo;\n      }, {})\n    };\n  }, null);\n}\n\nexport default matchPath;\n", "import React from \"react\";\nimport { isValidElementType } from \"react-is\";\nimport PropTypes from \"prop-types\";\nimport invariant from \"tiny-invariant\";\nimport warning from \"tiny-warning\";\n\nimport RouterContext from \"./RouterContext.js\";\nimport matchPath from \"./matchPath.js\";\n\nfunction isEmptyChildren(children) {\n  return React.Children.count(children) === 0;\n}\n\nfunction evalChildrenDev(children, props, path) {\n  const value = children(props);\n\n  warning(\n    value !== undefined,\n    \"You returned `undefined` from the `children` function of \" +\n      `<Route${path ? ` path=\"${path}\"` : \"\"}>, but you ` +\n      \"should have returned a React element or `null`\"\n  );\n\n  return value || null;\n}\n\n/**\n * The public API for matching a single path and rendering.\n */\nclass Route extends React.Component {\n  render() {\n    return (\n      <RouterContext.Consumer>\n        {context => {\n          invariant(context, \"You should not use <Route> outside a <Router>\");\n\n          const location = this.props.location || context.location;\n          const match = this.props.computedMatch\n            ? this.props.computedMatch // <Switch> already computed the match for us\n            : this.props.path\n            ? matchPath(location.pathname, this.props)\n            : context.match;\n\n          const props = { ...context, location, match };\n\n          let { children, component, render } = this.props;\n\n          // Preact uses an empty array as children by\n          // default, so use null if that's the case.\n          if (Array.isArray(children) && isEmptyChildren(children)) {\n            children = null;\n          }\n\n          return (\n            <RouterContext.Provider value={props}>\n              {props.match\n                ? children\n                  ? typeof children === \"function\"\n                    ? __DEV__\n                      ? evalChildrenDev(children, props, this.props.path)\n                      : children(props)\n                    : children\n                  : component\n                  ? React.createElement(component, props)\n                  : render\n                  ? render(props)\n                  : null\n                : typeof children === \"function\"\n                ? __DEV__\n                  ? evalChildrenDev(children, props, this.props.path)\n                  : children(props)\n                : null}\n            </RouterContext.Provider>\n          );\n        }}\n      </RouterContext.Consumer>\n    );\n  }\n}\n\nif (__DEV__) {\n  Route.propTypes = {\n    children: PropTypes.oneOfType([PropTypes.func, PropTypes.node]),\n    component: (props, propName) => {\n      if (props[propName] && !isValidElementType(props[propName])) {\n        return new Error(\n          `Invalid prop 'component' supplied to 'Route': the prop is not a valid React component`\n        );\n      }\n    },\n    exact: PropTypes.bool,\n    location: PropTypes.object,\n    path: PropTypes.oneOfType([\n      PropTypes.string,\n      PropTypes.arrayOf(PropTypes.string)\n    ]),\n    render: PropTypes.func,\n    sensitive: PropTypes.bool,\n    strict: PropTypes.bool\n  };\n\n  Route.prototype.componentDidMount = function() {\n    warning(\n      !(\n        this.props.children &&\n        !isEmptyChildren(this.props.children) &&\n        this.props.component\n      ),\n      \"You should not use <Route component> and <Route children> in the same route; <Route component> will be ignored\"\n    );\n\n    warning(\n      !(\n        this.props.children &&\n        !isEmptyChildren(this.props.children) &&\n        this.props.render\n      ),\n      \"You should not use <Route render> and <Route children> in the same route; <Route render> will be ignored\"\n    );\n\n    warning(\n      !(this.props.component && this.props.render),\n      \"You should not use <Route component> and <Route render> in the same route; <Route render> will be ignored\"\n    );\n  };\n\n  Route.prototype.componentDidUpdate = function(prevProps) {\n    warning(\n      !(this.props.location && !prevProps.location),\n      '<Route> elements should not change from uncontrolled to controlled (or vice versa). You initially used no \"location\" prop and then provided one on a subsequent render.'\n    );\n\n    warning(\n      !(!this.props.location && prevProps.location),\n      '<Route> elements should not change from controlled to uncontrolled (or vice versa). You provided a \"location\" prop initially but omitted it on a subsequent render.'\n    );\n  };\n}\n\nexport default Route;\n", "import React from \"react\";\nimport PropTypes from \"prop-types\";\nimport { createLocation, createPath } from \"history\";\nimport invariant from \"tiny-invariant\";\nimport warning from \"tiny-warning\";\n\nimport Router from \"./Router.js\";\n\nfunction addLeadingSlash(path) {\n  return path.charAt(0) === \"/\" ? path : \"/\" + path;\n}\n\nfunction addBasename(basename, location) {\n  if (!basename) return location;\n\n  return {\n    ...location,\n    pathname: addLeadingSlash(basename) + location.pathname\n  };\n}\n\nfunction stripBasename(basename, location) {\n  if (!basename) return location;\n\n  const base = addLeadingSlash(basename);\n\n  if (location.pathname.indexOf(base) !== 0) return location;\n\n  return {\n    ...location,\n    pathname: location.pathname.substr(base.length)\n  };\n}\n\nfunction createURL(location) {\n  return typeof location === \"string\" ? location : createPath(location);\n}\n\nfunction staticHandler(methodName) {\n  return () => {\n    invariant(false, \"You cannot %s with <StaticRouter>\", methodName);\n  };\n}\n\nfunction noop() {}\n\n/**\n * The public top-level API for a \"static\" <Router>, so-called because it\n * can't actually change the current location. Instead, it just records\n * location changes in a context object. Useful mainly in testing and\n * server-rendering scenarios.\n */\nclass StaticRouter extends React.Component {\n  navigateTo(location, action) {\n    const { basename = \"\", context = {} } = this.props;\n    context.action = action;\n    context.location = addBasename(basename, createLocation(location));\n    context.url = createURL(context.location);\n  }\n\n  handlePush = location => this.navigateTo(location, \"PUSH\");\n  handleReplace = location => this.navigateTo(location, \"REPLACE\");\n  handleListen = () => noop;\n  handleBlock = () => noop;\n\n  render() {\n    const { basename = \"\", context = {}, location = \"/\", ...rest } = this.props;\n\n    const history = {\n      createHref: path => addLeadingSlash(basename + createURL(path)),\n      action: \"POP\",\n      location: stripBasename(basename, createLocation(location)),\n      push: this.handlePush,\n      replace: this.handleReplace,\n      go: staticHandler(\"go\"),\n      goBack: staticHandler(\"goBack\"),\n      goForward: staticHandler(\"goForward\"),\n      listen: this.handleListen,\n      block: this.handleBlock\n    };\n\n    return <Router {...rest} history={history} staticContext={context} />;\n  }\n}\n\nif (__DEV__) {\n  StaticRouter.propTypes = {\n    basename: PropTypes.string,\n    context: PropTypes.object,\n    location: PropTypes.oneOfType([PropTypes.string, PropTypes.object])\n  };\n\n  StaticRouter.prototype.componentDidMount = function() {\n    warning(\n      !this.props.history,\n      \"<StaticRouter> ignores the history prop. To use a custom history, \" +\n        \"use `import { Router }` instead of `import { StaticRouter as Router }`.\"\n    );\n  };\n}\n\nexport default StaticRouter;\n", "import React from \"react\";\nimport PropTypes from \"prop-types\";\nimport invariant from \"tiny-invariant\";\nimport warning from \"tiny-warning\";\n\nimport RouterContext from \"./RouterContext.js\";\nimport matchPath from \"./matchPath.js\";\n\n/**\n * The public API for rendering the first <Route> that matches.\n */\nclass Switch extends React.Component {\n  render() {\n    return (\n      <RouterContext.Consumer>\n        {context => {\n          invariant(context, \"You should not use <Switch> outside a <Router>\");\n\n          const location = this.props.location || context.location;\n\n          let element, match;\n\n          // We use React.Children.forEach instead of React.Children.toArray().find()\n          // here because toArray adds keys to all child elements and we do not want\n          // to trigger an unmount/remount for two <Route>s that render the same\n          // component at different URLs.\n          React.Children.forEach(this.props.children, child => {\n            if (match == null && React.isValidElement(child)) {\n              element = child;\n\n              const path = child.props.path || child.props.from;\n\n              match = path\n                ? matchPath(location.pathname, { ...child.props, path })\n                : context.match;\n            }\n          });\n\n          return match\n            ? React.cloneElement(element, { location, computedMatch: match })\n            : null;\n        }}\n      </RouterContext.Consumer>\n    );\n  }\n}\n\nif (__DEV__) {\n  Switch.propTypes = {\n    children: PropTypes.node,\n    location: PropTypes.object\n  };\n\n  Switch.prototype.componentDidUpdate = function(prevProps) {\n    warning(\n      !(this.props.location && !prevProps.location),\n      '<Switch> elements should not change from uncontrolled to controlled (or vice versa). You initially used no \"location\" prop and then provided one on a subsequent render.'\n    );\n\n    warning(\n      !(!this.props.location && prevProps.location),\n      '<Switch> elements should not change from controlled to uncontrolled (or vice versa). You provided a \"location\" prop initially but omitted it on a subsequent render.'\n    );\n  };\n}\n\nexport default Switch;\n", "import React from \"react\";\nimport PropTypes from \"prop-types\";\nimport hoistStatics from \"hoist-non-react-statics\";\nimport invariant from \"tiny-invariant\";\n\nimport RouterContext from \"./RouterContext.js\";\n\n/**\n * A public higher-order component to access the imperative API\n */\nfunction withRouter(Component) {\n  const displayName = `withRouter(${Component.displayName || Component.name})`;\n  const C = props => {\n    const { wrappedComponentRef, ...remainingProps } = props;\n\n    return (\n      <RouterContext.Consumer>\n        {context => {\n          invariant(\n            context,\n            `You should not use <${displayName} /> outside a <Router>`\n          );\n          return (\n            <Component\n              {...remainingProps}\n              {...context}\n              ref={wrappedComponentRef}\n            />\n          );\n        }}\n      </RouterContext.Consumer>\n    );\n  };\n\n  C.displayName = displayName;\n  C.WrappedComponent = Component;\n\n  if (__DEV__) {\n    C.propTypes = {\n      wrappedComponentRef: PropTypes.oneOfType([\n        PropTypes.string,\n        PropTypes.func,\n        PropTypes.object\n      ])\n    };\n  }\n\n  return hoistStatics(C, Component);\n}\n\nexport default withRouter;\n", "import React from \"react\";\nimport invariant from \"tiny-invariant\";\n\nimport RouterContext from \"./RouterContext.js\";\nimport HistoryContext from \"./HistoryContext.js\";\nimport matchPath from \"./matchPath.js\";\n\nconst useContext = React.useContext;\n\nexport function useHistory() {\n  if (__DEV__) {\n    invariant(\n      typeof useContext === \"function\",\n      \"You must use React >= 16.8 in order to use useHistory()\"\n    );\n  }\n\n  return useContext(HistoryContext);\n}\n\nexport function useLocation() {\n  if (__DEV__) {\n    invariant(\n      typeof useContext === \"function\",\n      \"You must use React >= 16.8 in order to use useLocation()\"\n    );\n  }\n\n  return useContext(RouterContext).location;\n}\n\nexport function useParams() {\n  if (__DEV__) {\n    invariant(\n      typeof useContext === \"function\",\n      \"You must use React >= 16.8 in order to use useParams()\"\n    );\n  }\n\n  const match = useContext(RouterContext).match;\n  return match ? match.params : {};\n}\n\nexport function useRouteMatch(path) {\n  if (__DEV__) {\n    invariant(\n      typeof useContext === \"function\",\n      \"You must use React >= 16.8 in order to use useRouteMatch()\"\n    );\n  }\n\n  const location = useLocation();\n  const match = useContext(RouterContext).match;\n  return path ? matchPath(location.pathname, path) : match;\n}\n", "if (__DEV__) {\n  if (typeof window !== \"undefined\") {\n    const global = window;\n    const key = \"__react_router_build__\";\n    const buildNames = { cjs: \"CommonJS\", esm: \"ES modules\", umd: \"UMD\" };\n\n    if (global[key] && global[key] !== process.env.BUILD_FORMAT) {\n      const initialBuildName = buildNames[global[key]];\n      const secondaryBuildName = buildNames[process.env.BUILD_FORMAT];\n\n      // TODO: Add link to article that explains in detail how to avoid\n      // loading 2 different builds.\n      throw new Error(\n        `You are loading the ${secondaryBuildName} build of React Router ` +\n          `on a page that is already running the ${initialBuildName} ` +\n          `build, so things won't work right.`\n      );\n    }\n\n    global[key] = process.env.BUILD_FORMAT;\n  }\n}\n\nexport { default as MemoryRouter } from \"./MemoryRouter.js\";\nexport { default as Prompt } from \"./Prompt.js\";\nexport { default as Redirect } from \"./Redirect.js\";\nexport { default as Route } from \"./Route.js\";\nexport { default as Router } from \"./Router.js\";\nexport { default as StaticRouter } from \"./StaticRouter.js\";\nexport { default as Switch } from \"./Switch.js\";\nexport { default as generatePath } from \"./generatePath.js\";\nexport { default as matchPath } from \"./matchPath.js\";\nexport { default as withRouter } from \"./withRouter.js\";\n\nexport { default as __HistoryContext } from \"./HistoryContext.js\";\nexport { default as __RouterContext } from \"./RouterContext.js\";\n\nexport { useHistory, useLocation, useParams, useRouteMatch } from \"./hooks.js\";\n", "import type { IonRouteProps } from '@ionic/react';\nimport React from 'react';\nimport { Route } from 'react-router';\n\nexport class IonRouteInner extends React.PureComponent<IonRouteProps> {\n  render() {\n    return (\n      <Route\n        path={this.props.path}\n        exact={this.props.exact}\n        render={this.props.render}\n        /**\n         * `computedMatch` is a private API in react-router v5 that\n         * has been removed in v6.\n         *\n         * This needs to be removed when we support v6.\n         *\n         * TODO: FW-647\n         */\n        computedMatch={(this.props as any).computedMatch}\n      />\n    );\n  }\n}\n", "import type { RouteInfo, ViewItem } from '@ionic/react';\nimport { IonRoute, ViewLifeCycleManager, ViewStacks, generateId } from '@ionic/react';\nimport React from 'react';\nimport { matchPath } from 'react-router';\n\nexport class ReactRouterViewStack extends ViewStacks {\n  constructor() {\n    super();\n    this.createViewItem = this.createViewItem.bind(this);\n    this.findViewItemByRouteInfo = this.findViewItemByRouteInfo.bind(this);\n    this.findLeavingViewItemByRouteInfo = this.findLeavingViewItemByRouteInfo.bind(this);\n    this.getChildrenToRender = this.getChildrenToRender.bind(this);\n    this.findViewItemByPathname = this.findViewItemByPathname.bind(this);\n  }\n\n  createViewItem(outletId: string, reactElement: React.ReactElement, routeInfo: RouteInfo, page?: HTMLElement) {\n    const viewItem: ViewItem = {\n      id: generateId('viewItem'),\n      outletId,\n      ionPageElement: page,\n      reactElement,\n      mount: true,\n      ionRoute: false,\n    };\n\n    const matchProps = {\n      exact: reactElement.props.exact,\n      path: reactElement.props.path || reactElement.props.from,\n      component: reactElement.props.component,\n    };\n\n    const match = matchPath(routeInfo.pathname, matchProps);\n\n    if (reactElement.type === IonRoute) {\n      viewItem.ionRoute = true;\n      viewItem.disableIonPageManagement = reactElement.props.disableIonPageManagement;\n    }\n\n    viewItem.routeData = {\n      match,\n      childProps: reactElement.props,\n    };\n\n    return viewItem;\n  }\n\n  getChildrenToRender(outletId: string, ionRouterOutlet: React.ReactElement, routeInfo: RouteInfo) {\n    const viewItems = this.getViewItemsForOutlet(outletId);\n\n    // Sync latest routes with viewItems\n    React.Children.forEach(ionRouterOutlet.props.children, (child: React.ReactElement) => {\n      const viewItem = viewItems.find((v) => {\n        return matchComponent(child, v.routeData.childProps.path || v.routeData.childProps.from);\n      });\n      if (viewItem) {\n        viewItem.reactElement = child;\n      }\n    });\n\n    const children = viewItems.map((viewItem) => {\n      let clonedChild;\n      if (viewItem.ionRoute && !viewItem.disableIonPageManagement) {\n        clonedChild = (\n          <ViewLifeCycleManager\n            key={`view-${viewItem.id}`}\n            mount={viewItem.mount}\n            removeView={() => this.remove(viewItem)}\n          >\n            {React.cloneElement(viewItem.reactElement, {\n              computedMatch: viewItem.routeData.match,\n            })}\n          </ViewLifeCycleManager>\n        );\n      } else {\n        const match = matchComponent(viewItem.reactElement, routeInfo.pathname);\n        clonedChild = (\n          <ViewLifeCycleManager\n            key={`view-${viewItem.id}`}\n            mount={viewItem.mount}\n            removeView={() => this.remove(viewItem)}\n          >\n            {React.cloneElement(viewItem.reactElement, {\n              computedMatch: viewItem.routeData.match,\n            })}\n          </ViewLifeCycleManager>\n        );\n\n        if (!match && viewItem.routeData.match) {\n          viewItem.routeData.match = undefined;\n          viewItem.mount = false;\n        }\n      }\n\n      return clonedChild;\n    });\n    return children;\n  }\n\n  findViewItemByRouteInfo(routeInfo: RouteInfo, outletId?: string, updateMatch?: boolean) {\n    const { viewItem, match } = this.findViewItemByPath(routeInfo.pathname, outletId);\n    const shouldUpdateMatch = updateMatch === undefined || updateMatch === true;\n    if (shouldUpdateMatch && viewItem && match) {\n      viewItem.routeData.match = match;\n    }\n    return viewItem;\n  }\n\n  findLeavingViewItemByRouteInfo(routeInfo: RouteInfo, outletId?: string, mustBeIonRoute = true) {\n    const { viewItem } = this.findViewItemByPath(routeInfo.lastPathname!, outletId, false, mustBeIonRoute);\n    return viewItem;\n  }\n\n  findViewItemByPathname(pathname: string, outletId?: string) {\n    const { viewItem } = this.findViewItemByPath(pathname, outletId);\n    return viewItem;\n  }\n\n  private findViewItemByPath(pathname: string, outletId?: string, forceExact?: boolean, mustBeIonRoute?: boolean) {\n    let viewItem: ViewItem | undefined;\n    let match: ReturnType<typeof matchPath> | undefined;\n    let viewStack: ViewItem[];\n\n    if (outletId) {\n      viewStack = this.getViewItemsForOutlet(outletId);\n      viewStack.some(matchView);\n      if (!viewItem) {\n        viewStack.some(matchDefaultRoute);\n      }\n    } else {\n      const viewItems = this.getAllViewItems();\n      viewItems.some(matchView);\n      if (!viewItem) {\n        viewItems.some(matchDefaultRoute);\n      }\n    }\n\n    return { viewItem, match };\n\n    function matchView(v: ViewItem) {\n      if (mustBeIonRoute && !v.ionRoute) {\n        return false;\n      }\n      const matchProps = {\n        exact: forceExact ? true : v.routeData.childProps.exact,\n        path: v.routeData.childProps.path || v.routeData.childProps.from,\n        component: v.routeData.childProps.component,\n      };\n      const myMatch = matchPath(pathname, matchProps);\n      if (myMatch) {\n        viewItem = v;\n        match = myMatch;\n        return true;\n      }\n      return false;\n    }\n\n    function matchDefaultRoute(v: ViewItem) {\n      // try to find a route that doesn't have a path or from prop, that will be our default route\n      if (!v.routeData.childProps.path && !v.routeData.childProps.from) {\n        match = {\n          path: pathname,\n          url: pathname,\n          isExact: true,\n          params: {},\n        };\n        viewItem = v;\n        return true;\n      }\n      return false;\n    }\n  }\n}\n\nfunction matchComponent(node: React.ReactElement, pathname: string, forceExact?: boolean) {\n  const matchProps = {\n    exact: forceExact ? true : node.props.exact,\n    path: node.props.path || node.props.from,\n    component: node.props.component,\n  };\n  const match = matchPath(pathname, matchProps);\n\n  return match;\n}\n", "export function clonePageElement(leavingViewHtml: string | HTMLElement) {\n  let html: string;\n  if (typeof leavingViewHtml === 'string') {\n    html = leavingViewHtml;\n  } else {\n    html = leavingViewHtml.outerHTML;\n  }\n  if (document) {\n    const newEl = document.createElement('div');\n    newEl.innerHTML = html;\n    newEl.style.zIndex = '';\n    // Remove an existing back button so the new element doesn't get two of them\n    const ionBackButton = newEl.getElementsByTagName('ion-back-button');\n    if (ionBackButton[0]) {\n      ionBackButton[0].remove();\n    }\n    return newEl.firstChild as HTMLElement;\n  }\n  return undefined;\n}\n", "import type { RouteInfo, StackContextState, ViewItem } from '@ionic/react';\nimport { RouteManagerContext, StackContext, generateId, getConfig } from '@ionic/react';\nimport React from 'react';\nimport { matchPath } from 'react-router-dom';\n\nimport { clonePageElement } from './clonePageElement';\n\n// TODO(FW-2959): types\n\ninterface StackManagerProps {\n  routeInfo: RouteInfo;\n}\n\n// eslint-disable-next-line @typescript-eslint/no-empty-interface\ninterface StackManagerState {}\n\nconst isViewVisible = (el: HTMLElement) =>\n  !el.classList.contains('ion-page-invisible') && !el.classList.contains('ion-page-hidden');\n\nexport class StackManager extends React.PureComponent<StackManagerProps, StackManagerState> {\n  id: string;\n  context!: React.ContextType<typeof RouteManagerContext>;\n  ionRouterOutlet?: React.ReactElement;\n  routerOutletElement: HTMLIonRouterOutletElement | undefined;\n  prevProps?: StackManagerProps;\n  skipTransition: boolean;\n\n  stackContextValue: StackContextState = {\n    registerIonPage: this.registerIonPage.bind(this),\n    isInOutlet: () => true,\n  };\n\n  private clearOutletTimeout: any;\n  private pendingPageTransition = false;\n\n  constructor(props: StackManagerProps) {\n    super(props);\n    this.registerIonPage = this.registerIonPage.bind(this);\n    this.transitionPage = this.transitionPage.bind(this);\n    this.handlePageTransition = this.handlePageTransition.bind(this);\n    this.id = generateId('routerOutlet');\n    this.prevProps = undefined;\n    this.skipTransition = false;\n  }\n\n  componentDidMount() {\n    if (this.clearOutletTimeout) {\n      /**\n       * The clearOutlet integration with React Router is a bit hacky.\n       * It uses a timeout to clear the outlet after a transition.\n       * In React v18, components are mounted and unmounted in development mode\n       * to check for side effects.\n       *\n       * This clearTimeout prevents the outlet from being cleared when the component is re-mounted,\n       * which should only happen in development mode and as a result of a hot reload.\n       */\n      clearTimeout(this.clearOutletTimeout);\n    }\n    if (this.routerOutletElement) {\n      this.setupRouterOutlet(this.routerOutletElement);\n      this.handlePageTransition(this.props.routeInfo);\n    }\n  }\n\n  componentDidUpdate(prevProps: StackManagerProps) {\n    const { pathname } = this.props.routeInfo;\n    const { pathname: prevPathname } = prevProps.routeInfo;\n\n    if (pathname !== prevPathname) {\n      this.prevProps = prevProps;\n      this.handlePageTransition(this.props.routeInfo);\n    } else if (this.pendingPageTransition) {\n      this.handlePageTransition(this.props.routeInfo);\n      this.pendingPageTransition = false;\n    }\n  }\n\n  componentWillUnmount() {\n    this.clearOutletTimeout = this.context.clearOutlet(this.id);\n  }\n\n  async handlePageTransition(routeInfo: RouteInfo) {\n    if (!this.routerOutletElement || !this.routerOutletElement.commit) {\n      /**\n       * The route outlet has not mounted yet. We need to wait for it to render\n       * before we can transition the page.\n       *\n       * Set a flag to indicate that we should transition the page after\n       * the component has updated.\n       */\n      this.pendingPageTransition = true;\n    } else {\n      let enteringViewItem = this.context.findViewItemByRouteInfo(routeInfo, this.id);\n      let leavingViewItem = this.context.findLeavingViewItemByRouteInfo(routeInfo, this.id);\n\n      if (!leavingViewItem && routeInfo.prevRouteLastPathname) {\n        leavingViewItem = this.context.findViewItemByPathname(routeInfo.prevRouteLastPathname, this.id);\n      }\n\n      // Check if leavingViewItem should be unmounted\n      if (leavingViewItem) {\n        if (routeInfo.routeAction === 'replace') {\n          leavingViewItem.mount = false;\n        } else if (!(routeInfo.routeAction === 'push' && routeInfo.routeDirection === 'forward')) {\n          if (routeInfo.routeDirection !== 'none' && enteringViewItem !== leavingViewItem) {\n            leavingViewItem.mount = false;\n          }\n        } else if (routeInfo.routeOptions?.unmount) {\n          leavingViewItem.mount = false;\n        }\n      }\n\n      const enteringRoute = matchRoute(this.ionRouterOutlet?.props.children, routeInfo) as React.ReactElement;\n\n      if (enteringViewItem) {\n        enteringViewItem.reactElement = enteringRoute;\n      } else if (enteringRoute) {\n        enteringViewItem = this.context.createViewItem(this.id, enteringRoute, routeInfo);\n        this.context.addViewItem(enteringViewItem);\n      }\n\n      if (enteringViewItem && enteringViewItem.ionPageElement) {\n        /**\n         * If the entering view item is the same as the leaving view item,\n         * then we don't need to transition.\n         */\n        if (enteringViewItem === leavingViewItem) {\n          /**\n           * If the entering view item is the same as the leaving view item,\n           * we are either transitioning using parameterized routes to the same view\n           * or a parent router outlet is re-rendering as a result of React props changing.\n           *\n           * If the route data does not match the current path, the parent router outlet\n           * is attempting to transition and we cancel the operation.\n           */\n          if (enteringViewItem.routeData.match.url !== routeInfo.pathname) {\n            return;\n          }\n        }\n\n        /**\n         * If there isn't a leaving view item, but the route info indicates\n         * that the user has routed from a previous path, then we need\n         * to find the leaving view item to transition between.\n         */\n        if (!leavingViewItem && this.props.routeInfo.prevRouteLastPathname) {\n          leavingViewItem = this.context.findViewItemByPathname(this.props.routeInfo.prevRouteLastPathname, this.id);\n        }\n\n        /**\n         * If the entering view is already visible and the leaving view is not, the transition does not need to occur.\n         */\n        if (\n          isViewVisible(enteringViewItem.ionPageElement) &&\n          leavingViewItem !== undefined &&\n          !isViewVisible(leavingViewItem.ionPageElement!)\n        ) {\n          return;\n        }\n\n        /**\n         * The view should only be transitioned in the following cases:\n         * 1. Performing a replace or pop action, such as a swipe to go back gesture\n         * to animation the leaving view off the screen.\n         *\n         * 2. Navigating between top-level router outlets, such as /page-1 to /page-2;\n         * or navigating within a nested outlet, such as /tabs/tab-1 to /tabs/tab-2.\n         *\n         * 3. The entering view is an ion-router-outlet containing a page\n         * matching the current route and that hasn't already transitioned in.\n         *\n         * This should only happen when navigating directly to a nested router outlet\n         * route or on an initial page load (i.e. refreshing). In cases when loading\n         * /tabs/tab-1, we need to transition the /tabs page element into the view.\n         */\n        this.transitionPage(routeInfo, enteringViewItem, leavingViewItem);\n      } else if (leavingViewItem && !enteringRoute && !enteringViewItem) {\n        // If we have a leavingView but no entering view/route, we are probably leaving to\n        // another outlet, so hide this leavingView. We do it in a timeout to give time for a\n        // transition to finish.\n        // setTimeout(() => {\n        if (leavingViewItem.ionPageElement) {\n          leavingViewItem.ionPageElement.classList.add('ion-page-hidden');\n          leavingViewItem.ionPageElement.setAttribute('aria-hidden', 'true');\n        }\n        // }, 250);\n      }\n\n      this.forceUpdate();\n    }\n  }\n\n  registerIonPage(page: HTMLElement, routeInfo: RouteInfo) {\n    const foundView = this.context.findViewItemByRouteInfo(routeInfo, this.id);\n    if (foundView) {\n      const oldPageElement = foundView.ionPageElement;\n      foundView.ionPageElement = page;\n      foundView.ionRoute = true;\n\n      /**\n       * React 18 will unmount and remount IonPage\n       * elements in development mode when using createRoot.\n       * This can cause duplicate page transitions to occur.\n       */\n      if (oldPageElement === page) {\n        return;\n      }\n    }\n    this.handlePageTransition(routeInfo);\n  }\n\n  async setupRouterOutlet(routerOutlet: HTMLIonRouterOutletElement) {\n    const canStart = () => {\n      const config = getConfig();\n      const swipeEnabled = config && config.get('swipeBackEnabled', routerOutlet.mode === 'ios');\n      if (!swipeEnabled) {\n        return false;\n      }\n\n      const { routeInfo } = this.props;\n\n      const propsToUse =\n        this.prevProps && this.prevProps.routeInfo.pathname === routeInfo.pushedByRoute\n          ? this.prevProps.routeInfo\n          : ({ pathname: routeInfo.pushedByRoute || '' } as any);\n      const enteringViewItem = this.context.findViewItemByRouteInfo(propsToUse, this.id, false);\n\n      return (\n        !!enteringViewItem &&\n        /**\n         * The root url '/' is treated as\n         * the first view item (but is never mounted),\n         * so we do not want to swipe back to the\n         * root url.\n         */\n        enteringViewItem.mount &&\n        /**\n         * When on the first page (whatever view\n         * you land on after the root url) it\n         * is possible for findViewItemByRouteInfo to\n         * return the exact same view you are currently on.\n         * Make sure that we are not swiping back to the same\n         * instances of a view.\n         */\n        enteringViewItem.routeData.match.path !== routeInfo.pathname\n      );\n    };\n\n    const onStart = async () => {\n      const { routeInfo } = this.props;\n\n      const propsToUse =\n        this.prevProps && this.prevProps.routeInfo.pathname === routeInfo.pushedByRoute\n          ? this.prevProps.routeInfo\n          : ({ pathname: routeInfo.pushedByRoute || '' } as any);\n      const enteringViewItem = this.context.findViewItemByRouteInfo(propsToUse, this.id, false);\n      const leavingViewItem = this.context.findViewItemByRouteInfo(routeInfo, this.id, false);\n\n      /**\n       * When the gesture starts, kick off\n       * a transition that is controlled\n       * via a swipe gesture.\n       */\n      if (enteringViewItem && leavingViewItem) {\n        await this.transitionPage(routeInfo, enteringViewItem, leavingViewItem, 'back', true);\n      }\n\n      return Promise.resolve();\n    };\n    const onEnd = (shouldContinue: boolean) => {\n      if (shouldContinue) {\n        this.skipTransition = true;\n\n        this.context.goBack();\n      } else {\n        /**\n         * In the event that the swipe\n         * gesture was aborted, we should\n         * re-hide the page that was going to enter.\n         */\n        const { routeInfo } = this.props;\n\n        const propsToUse =\n          this.prevProps && this.prevProps.routeInfo.pathname === routeInfo.pushedByRoute\n            ? this.prevProps.routeInfo\n            : ({ pathname: routeInfo.pushedByRoute || '' } as any);\n        const enteringViewItem = this.context.findViewItemByRouteInfo(propsToUse, this.id, false);\n        const leavingViewItem = this.context.findViewItemByRouteInfo(routeInfo, this.id, false);\n\n        /**\n         * Ionic React has a design defect where it\n         * a) Unmounts the leaving view item when using parameterized routes\n         * b) Considers the current view to be the entering view when using\n         * parameterized routes\n         *\n         * As a result, we should not hide the view item here\n         * as it will cause the current view to be hidden.\n         */\n        if (enteringViewItem !== leavingViewItem && enteringViewItem?.ionPageElement !== undefined) {\n          const { ionPageElement } = enteringViewItem;\n          ionPageElement.setAttribute('aria-hidden', 'true');\n          ionPageElement.classList.add('ion-page-hidden');\n        }\n      }\n    };\n\n    routerOutlet.swipeHandler = {\n      canStart,\n      onStart,\n      onEnd,\n    };\n  }\n\n  async transitionPage(\n    routeInfo: RouteInfo,\n    enteringViewItem: ViewItem,\n    leavingViewItem?: ViewItem,\n    direction?: 'forward' | 'back',\n    progressAnimation = false\n  ) {\n    const runCommit = async (enteringEl: HTMLElement, leavingEl?: HTMLElement) => {\n      const skipTransition = this.skipTransition;\n\n      /**\n       * If the transition was handled\n       * via the swipe to go back gesture,\n       * then we do not want to perform\n       * another transition.\n       *\n       * We skip adding ion-page or ion-page-invisible\n       * because the entering view already exists in the DOM.\n       * If we added the classes, there would be a flicker where\n       * the view would be briefly hidden.\n       */\n      if (skipTransition) {\n        /**\n         * We need to reset skipTransition before\n         * we call routerOutlet.commit otherwise\n         * the transition triggered by the swipe\n         * to go back gesture would reset it. In\n         * that case you would see a duplicate\n         * transition triggered by handlePageTransition\n         * in componentDidUpdate.\n         */\n        this.skipTransition = false;\n      } else {\n        enteringEl.classList.add('ion-page');\n        enteringEl.classList.add('ion-page-invisible');\n      }\n\n      await routerOutlet.commit(enteringEl, leavingEl, {\n        deepWait: true,\n        duration: skipTransition || directionToUse === undefined ? 0 : undefined,\n        direction: directionToUse,\n        showGoBack: !!routeInfo.pushedByRoute,\n        progressAnimation,\n        animationBuilder: routeInfo.routeAnimation,\n      });\n    };\n\n    const routerOutlet = this.routerOutletElement!;\n\n    const routeInfoFallbackDirection =\n      routeInfo.routeDirection === 'none' || routeInfo.routeDirection === 'root' ? undefined : routeInfo.routeDirection;\n    const directionToUse = direction ?? routeInfoFallbackDirection;\n\n    if (enteringViewItem && enteringViewItem.ionPageElement && this.routerOutletElement) {\n      if (leavingViewItem && leavingViewItem.ionPageElement && enteringViewItem === leavingViewItem) {\n        // If a page is transitioning to another version of itself\n        // we clone it so we can have an animation to show\n\n        const match = matchComponent(leavingViewItem.reactElement, routeInfo.pathname, true);\n        if (match) {\n          const newLeavingElement = clonePageElement(leavingViewItem.ionPageElement.outerHTML);\n          if (newLeavingElement) {\n            this.routerOutletElement.appendChild(newLeavingElement);\n            await runCommit(enteringViewItem.ionPageElement, newLeavingElement);\n            this.routerOutletElement.removeChild(newLeavingElement);\n          }\n        } else {\n          await runCommit(enteringViewItem.ionPageElement, undefined);\n        }\n      } else {\n        await runCommit(enteringViewItem.ionPageElement, leavingViewItem?.ionPageElement);\n        if (leavingViewItem && leavingViewItem.ionPageElement && !progressAnimation) {\n          leavingViewItem.ionPageElement.classList.add('ion-page-hidden');\n          leavingViewItem.ionPageElement.setAttribute('aria-hidden', 'true');\n        }\n      }\n    }\n  }\n\n  render() {\n    const { children } = this.props;\n    const ionRouterOutlet = React.Children.only(children) as React.ReactElement;\n    this.ionRouterOutlet = ionRouterOutlet;\n\n    const components = this.context.getChildrenToRender(this.id, this.ionRouterOutlet, this.props.routeInfo, () => {\n      this.forceUpdate();\n    });\n\n    return (\n      <StackContext.Provider value={this.stackContextValue}>\n        {React.cloneElement(\n          ionRouterOutlet as any,\n          {\n            ref: (node: HTMLIonRouterOutletElement) => {\n              if (ionRouterOutlet.props.setRef) {\n                ionRouterOutlet.props.setRef(node);\n              }\n              if (ionRouterOutlet.props.forwardedRef) {\n                ionRouterOutlet.props.forwardedRef.current = node;\n              }\n              this.routerOutletElement = node;\n              const { ref } = ionRouterOutlet as any;\n              if (typeof ref === 'function') {\n                ref(node);\n              }\n            },\n          },\n          components\n        )}\n      </StackContext.Provider>\n    );\n  }\n\n  static get contextType() {\n    return RouteManagerContext;\n  }\n}\n\nexport default StackManager;\n\nfunction matchRoute(node: React.ReactNode, routeInfo: RouteInfo) {\n  let matchedNode: React.ReactNode;\n  React.Children.forEach(node as React.ReactElement, (child: React.ReactElement) => {\n    const matchProps = {\n      exact: child.props.exact,\n      path: child.props.path || child.props.from,\n      component: child.props.component,\n    };\n    const match = matchPath(routeInfo.pathname, matchProps);\n    if (match) {\n      matchedNode = child;\n    }\n  });\n\n  if (matchedNode) {\n    return matchedNode;\n  }\n  // If we haven't found a node\n  // try to find one that doesn't have a path or from prop, that will be our not found route\n  React.Children.forEach(node as React.ReactElement, (child: React.ReactElement) => {\n    if (!(child.props.path || child.props.from)) {\n      matchedNode = child;\n    }\n  });\n\n  return matchedNode;\n}\n\nfunction matchComponent(node: React.ReactElement, pathname: string, forceExact?: boolean) {\n  const matchProps = {\n    exact: forceExact ? true : node.props.exact,\n    path: node.props.path || node.props.from,\n    component: node.props.component,\n  };\n  const match = matchPath(pathname, matchProps);\n\n  return match;\n}\n", "import type {\n  AnimationBuilder,\n  RouteAction,\n  RouteInfo,\n  RouteManagerContextState,\n  RouterDirection,\n  ViewItem,\n} from '@ionic/react';\nimport { LocationHistory, NavManager, RouteManagerContext, generateId, getConfig } from '@ionic/react';\nimport type { Action as HistoryAction, Location as HistoryLocation } from 'history';\nimport React from 'react';\nimport type { RouteComponentProps } from 'react-router-dom';\nimport { withRouter } from 'react-router-dom';\n\nimport { IonRouteInner } from './IonRouteInner';\nimport { ReactRouterViewStack } from './ReactRouterViewStack';\nimport StackManager from './StackManager';\n\nexport interface LocationState {\n  direction?: RouterDirection;\n  routerOptions?: { as?: string; unmount?: boolean };\n}\n\ninterface IonRouteProps extends RouteComponentProps<{}, {}, LocationState> {\n  registerHistoryListener: (cb: (location: HistoryLocation<any>, action: HistoryAction) => void) => void;\n}\n\ninterface IonRouteState {\n  routeInfo: RouteInfo;\n}\n\nclass IonRouterInner extends React.PureComponent<IonRouteProps, IonRouteState> {\n  currentTab?: string;\n  exitViewFromOtherOutletHandlers: ((pathname: string) => ViewItem | undefined)[] = [];\n  incomingRouteParams?: Partial<RouteInfo>;\n  locationHistory = new LocationHistory();\n  viewStack = new ReactRouterViewStack();\n  routeMangerContextState: RouteManagerContextState = {\n    canGoBack: () => this.locationHistory.canGoBack(),\n    clearOutlet: this.viewStack.clear,\n    findViewItemByPathname: this.viewStack.findViewItemByPathname,\n    getChildrenToRender: this.viewStack.getChildrenToRender,\n    goBack: () => this.handleNavigateBack(),\n    createViewItem: this.viewStack.createViewItem,\n    findViewItemByRouteInfo: this.viewStack.findViewItemByRouteInfo,\n    findLeavingViewItemByRouteInfo: this.viewStack.findLeavingViewItemByRouteInfo,\n    addViewItem: this.viewStack.add,\n    unMountViewItem: this.viewStack.remove,\n  };\n\n  constructor(props: IonRouteProps) {\n    super(props);\n\n    const routeInfo = {\n      id: generateId('routeInfo'),\n      pathname: this.props.location.pathname,\n      search: this.props.location.search,\n    };\n\n    this.locationHistory.add(routeInfo);\n    this.handleChangeTab = this.handleChangeTab.bind(this);\n    this.handleResetTab = this.handleResetTab.bind(this);\n    this.handleNativeBack = this.handleNativeBack.bind(this);\n    this.handleNavigate = this.handleNavigate.bind(this);\n    this.handleNavigateBack = this.handleNavigateBack.bind(this);\n    this.props.registerHistoryListener(this.handleHistoryChange.bind(this));\n    this.handleSetCurrentTab = this.handleSetCurrentTab.bind(this);\n\n    this.state = {\n      routeInfo,\n    };\n  }\n\n  handleChangeTab(tab: string, path?: string, routeOptions?: any) {\n    if (!path) {\n      return;\n    }\n\n    const routeInfo = this.locationHistory.getCurrentRouteInfoForTab(tab);\n    const [pathname, search] = path.split('?');\n    if (routeInfo) {\n      this.incomingRouteParams = { ...routeInfo, routeAction: 'push', routeDirection: 'none' };\n      if (routeInfo.pathname === pathname) {\n        this.incomingRouteParams.routeOptions = routeOptions;\n        this.props.history.push(routeInfo.pathname + (routeInfo.search || ''));\n      } else {\n        this.incomingRouteParams.pathname = pathname;\n        this.incomingRouteParams.search = search ? '?' + search : undefined;\n        this.incomingRouteParams.routeOptions = routeOptions;\n        this.props.history.push(pathname + (search ? '?' + search : ''));\n      }\n    } else {\n      this.handleNavigate(pathname, 'push', 'none', undefined, routeOptions, tab);\n    }\n  }\n\n  handleHistoryChange(location: HistoryLocation<LocationState>, action: HistoryAction) {\n    let leavingLocationInfo: RouteInfo;\n    if (this.incomingRouteParams) {\n      if (this.incomingRouteParams.routeAction === 'replace') {\n        leavingLocationInfo = this.locationHistory.previous();\n      } else {\n        leavingLocationInfo = this.locationHistory.current();\n      }\n    } else {\n      leavingLocationInfo = this.locationHistory.current();\n    }\n\n    const leavingUrl = leavingLocationInfo.pathname + leavingLocationInfo.search;\n    if (leavingUrl !== location.pathname) {\n      if (!this.incomingRouteParams) {\n        if (action === 'REPLACE') {\n          this.incomingRouteParams = {\n            routeAction: 'replace',\n            routeDirection: 'none',\n            tab: this.currentTab,\n          };\n        }\n        if (action === 'POP') {\n          const currentRoute = this.locationHistory.current();\n          if (currentRoute && currentRoute.pushedByRoute) {\n            const prevInfo = this.locationHistory.findLastLocation(currentRoute);\n            this.incomingRouteParams = { ...prevInfo, routeAction: 'pop', routeDirection: 'back' };\n          } else {\n            this.incomingRouteParams = {\n              routeAction: 'pop',\n              routeDirection: 'none',\n              tab: this.currentTab,\n            };\n          }\n        }\n        if (!this.incomingRouteParams) {\n          this.incomingRouteParams = {\n            routeAction: 'push',\n            routeDirection: location.state?.direction || 'forward',\n            routeOptions: location.state?.routerOptions,\n            tab: this.currentTab,\n          };\n        }\n      }\n\n      let routeInfo: RouteInfo;\n\n      if (this.incomingRouteParams?.id) {\n        routeInfo = {\n          ...(this.incomingRouteParams as RouteInfo),\n          lastPathname: leavingLocationInfo.pathname,\n        };\n        this.locationHistory.add(routeInfo);\n      } else {\n        const isPushed =\n          this.incomingRouteParams.routeAction === 'push' && this.incomingRouteParams.routeDirection === 'forward';\n        routeInfo = {\n          id: generateId('routeInfo'),\n          ...this.incomingRouteParams,\n          lastPathname: leavingLocationInfo.pathname,\n          pathname: location.pathname,\n          search: location.search,\n          params: this.props.match.params,\n          prevRouteLastPathname: leavingLocationInfo.lastPathname,\n        };\n        if (isPushed) {\n          routeInfo.tab = leavingLocationInfo.tab;\n          routeInfo.pushedByRoute = leavingLocationInfo.pathname;\n        } else if (routeInfo.routeAction === 'pop') {\n          const r = this.locationHistory.findLastLocation(routeInfo);\n          routeInfo.pushedByRoute = r?.pushedByRoute;\n        } else if (routeInfo.routeAction === 'push' && routeInfo.tab !== leavingLocationInfo.tab) {\n          // If we are switching tabs grab the last route info for the tab and use its pushedByRoute\n          const lastRoute = this.locationHistory.getCurrentRouteInfoForTab(routeInfo.tab);\n          routeInfo.pushedByRoute = lastRoute?.pushedByRoute;\n        } else if (routeInfo.routeAction === 'replace') {\n          // Make sure to set the lastPathname, etc.. to the current route so the page transitions out\n          const currentRouteInfo = this.locationHistory.current();\n\n          /**\n           * If going from /home to /child, then replacing from\n           * /child to /home, we don't want the route info to\n           * say that /home was pushed by /home which is not correct.\n           */\n          const currentPushedBy = currentRouteInfo?.pushedByRoute;\n          const pushedByRoute =\n            currentPushedBy !== undefined && currentPushedBy !== routeInfo.pathname\n              ? currentPushedBy\n              : routeInfo.pushedByRoute;\n\n          routeInfo.lastPathname = currentRouteInfo?.pathname || routeInfo.lastPathname;\n          routeInfo.prevRouteLastPathname = currentRouteInfo?.lastPathname;\n          routeInfo.pushedByRoute = pushedByRoute;\n          routeInfo.routeDirection = currentRouteInfo?.routeDirection || routeInfo.routeDirection;\n          routeInfo.routeAnimation = currentRouteInfo?.routeAnimation || routeInfo.routeAnimation;\n        }\n\n        this.locationHistory.add(routeInfo);\n      }\n\n      this.setState({\n        routeInfo,\n      });\n    }\n\n    this.incomingRouteParams = undefined;\n  }\n\n  /**\n   * history@4.x uses goBack(), history@5.x uses back()\n   * TODO: If support for React Router <=5 is dropped\n   * this logic is no longer needed. We can just\n   * assume back() is available.\n   */\n  handleNativeBack() {\n    const history = this.props.history as any;\n    const goBack = history.goBack || history.back;\n    goBack();\n  }\n\n  handleNavigate(\n    path: string,\n    routeAction: RouteAction,\n    routeDirection?: RouterDirection,\n    routeAnimation?: AnimationBuilder,\n    routeOptions?: any,\n    tab?: string\n  ) {\n    this.incomingRouteParams = Object.assign(this.incomingRouteParams || {}, {\n      routeAction,\n      routeDirection,\n      routeOptions,\n      routeAnimation,\n      tab,\n    });\n\n    if (routeAction === 'push') {\n      this.props.history.push(path);\n    } else {\n      this.props.history.replace(path);\n    }\n  }\n\n  handleNavigateBack(defaultHref: string | RouteInfo = '/', routeAnimation?: AnimationBuilder) {\n    const config = getConfig();\n    defaultHref = defaultHref ? defaultHref : config && config.get('backButtonDefaultHref' as any);\n    const routeInfo = this.locationHistory.current();\n    if (routeInfo && routeInfo.pushedByRoute) {\n      const prevInfo = this.locationHistory.findLastLocation(routeInfo);\n      if (prevInfo) {\n        this.incomingRouteParams = {\n          ...prevInfo,\n          routeAction: 'pop',\n          routeDirection: 'back',\n          routeAnimation: routeAnimation || routeInfo.routeAnimation,\n        };\n        if (\n          routeInfo.lastPathname === routeInfo.pushedByRoute ||\n          /**\n           * We need to exclude tab switches/tab\n           * context changes here because tabbed\n           * navigation is not linear, but router.back()\n           * will go back in a linear fashion.\n           */\n          (prevInfo.pathname === routeInfo.pushedByRoute && routeInfo.tab === '' && prevInfo.tab === '')\n        ) {\n          /**\n           * history@4.x uses goBack(), history@5.x uses back()\n           * TODO: If support for React Router <=5 is dropped\n           * this logic is no longer needed. We can just\n           * assume back() is available.\n           */\n          const history = this.props.history as any;\n          const goBack = history.goBack || history.back;\n          goBack();\n        } else {\n          this.handleNavigate(prevInfo.pathname + (prevInfo.search || ''), 'pop', 'back');\n        }\n      } else {\n        this.handleNavigate(defaultHref as string, 'pop', 'back');\n      }\n    } else {\n      this.handleNavigate(defaultHref as string, 'pop', 'back');\n    }\n  }\n\n  handleResetTab(tab: string, originalHref: string, originalRouteOptions: any) {\n    const routeInfo = this.locationHistory.getFirstRouteInfoForTab(tab);\n    if (routeInfo) {\n      const newRouteInfo = { ...routeInfo };\n      newRouteInfo.pathname = originalHref;\n      newRouteInfo.routeOptions = originalRouteOptions;\n      this.incomingRouteParams = { ...newRouteInfo, routeAction: 'pop', routeDirection: 'back' };\n      this.props.history.push(newRouteInfo.pathname + (newRouteInfo.search || ''));\n    }\n  }\n\n  handleSetCurrentTab(tab: string) {\n    this.currentTab = tab;\n    const ri = { ...this.locationHistory.current() };\n    if (ri.tab !== tab) {\n      ri.tab = tab;\n      this.locationHistory.update(ri);\n    }\n  }\n\n  render() {\n    return (\n      <RouteManagerContext.Provider value={this.routeMangerContextState}>\n        <NavManager\n          ionRoute={IonRouteInner}\n          ionRedirect={{}}\n          stackManager={StackManager}\n          routeInfo={this.state.routeInfo!}\n          onNativeBack={this.handleNativeBack}\n          onNavigateBack={this.handleNavigateBack}\n          onNavigate={this.handleNavigate}\n          onSetCurrentTab={this.handleSetCurrentTab}\n          onChangeTab={this.handleChangeTab}\n          onResetTab={this.handleResetTab}\n          locationHistory={this.locationHistory}\n        >\n          {this.props.children}\n        </NavManager>\n      </RouteManagerContext.Provider>\n    );\n  }\n}\n\nexport const IonRouter = withRouter(IonRouterInner);\nIonRouter.displayName = 'IonRouter';\n", "import type { Action as HistoryAction, History, Location as HistoryLocation } from 'history';\nimport { createBrowserHistory as createHistory } from 'history';\nimport React from 'react';\nimport type { BrowserRouterProps } from 'react-router-dom';\nimport { Router } from 'react-router-dom';\n\nimport { IonRouter } from './IonRouter';\n\ninterface IonReactRouterProps extends BrowserRouterProps {\n  history?: History;\n}\n\nexport class IonReactRouter extends React.Component<IonReactRouterProps> {\n  historyListenHandler?: (location: HistoryLocation, action: HistoryAction) => void;\n  history: History;\n\n  constructor(props: IonReactRouterProps) {\n    super(props);\n    const { history, ...rest } = props;\n    this.history = history || createHistory(rest);\n    this.history.listen(this.handleHistoryChange.bind(this));\n    this.registerHistoryListener = this.registerHistoryListener.bind(this);\n  }\n\n  /**\n   * history@4.x passes separate location and action\n   * params. history@5.x passes location and action\n   * together as a single object.\n   * TODO: If support for React Router <=5 is dropped\n   * this logic is no longer needed. We can just assume\n   * a single object with both location and action.\n   */\n  handleHistoryChange(location: HistoryLocation, action: HistoryAction) {\n    const locationValue = (location as any).location || location;\n    const actionValue = (location as any).action || action;\n    if (this.historyListenHandler) {\n      this.historyListenHandler(locationValue, actionValue);\n    }\n  }\n\n  registerHistoryListener(cb: (location: HistoryLocation, action: HistoryAction) => void) {\n    this.historyListenHandler = cb;\n  }\n\n  render() {\n    const { children, ...props } = this.props;\n    return (\n      <Router history={this.history} {...props}>\n        <IonRouter registerHistoryListener={this.registerHistoryListener}>{children}</IonRouter>\n      </Router>\n    );\n  }\n}\n", "import type { Action as HistoryAction, Location as HistoryLocation, MemoryHistory } from 'history';\nimport React from 'react';\nimport type { MemoryRouterProps } from 'react-router';\nimport { Router } from 'react-router';\n\nimport { IonRouter } from './IonRouter';\n\ninterface IonReactMemoryRouterProps extends MemoryRouterProps {\n  history: MemoryHistory;\n}\n\nexport class IonReactMemoryRouter extends React.Component<IonReactMemoryRouterProps> {\n  history: MemoryHistory;\n  historyListenHandler?: (location: HistoryLocation, action: HistoryAction) => void;\n\n  constructor(props: IonReactMemoryRouterProps) {\n    super(props);\n    this.history = props.history;\n    this.history.listen(this.handleHistoryChange.bind(this));\n    this.registerHistoryListener = this.registerHistoryListener.bind(this);\n  }\n\n  /**\n   * history@4.x passes separate location and action\n   * params. history@5.x passes location and action\n   * together as a single object.\n   * TODO: If support for React Router <=5 is dropped\n   * this logic is no longer needed. We can just assume\n   * a single object with both location and action.\n   */\n  handleHistoryChange(location: HistoryLocation, action: HistoryAction) {\n    const locationValue = (location as any).location || location;\n    const actionValue = (location as any).action || action;\n    if (this.historyListenHandler) {\n      this.historyListenHandler(locationValue, actionValue);\n    }\n  }\n\n  registerHistoryListener(cb: (location: HistoryLocation, action: HistoryAction) => void) {\n    this.historyListenHandler = cb;\n  }\n\n  render() {\n    const { children, ...props } = this.props;\n    return (\n      <Router {...props}>\n        <IonRouter registerHistoryListener={this.registerHistoryListener}>{children}</IonRouter>\n      </Router>\n    );\n  }\n}\n", "import type { Action as HistoryAction, History, Location as HistoryLocation } from 'history';\nimport { createHashHistory as createHistory } from 'history';\nimport React from 'react';\nimport type { BrowserRouterProps } from 'react-router-dom';\nimport { Router } from 'react-router-dom';\n\nimport { IonRouter } from './IonRouter';\n\ninterface IonReactHashRouterProps extends BrowserRouterProps {\n  history?: History;\n}\n\nexport class IonReactHashRouter extends React.Component<IonReactHashRouterProps> {\n  history: History;\n  historyListenHandler?: (location: HistoryLocation, action: HistoryAction) => void;\n\n  constructor(props: IonReactHashRouterProps) {\n    super(props);\n    const { history, ...rest } = props;\n    this.history = history || createHistory(rest);\n    this.history.listen(this.handleHistoryChange.bind(this));\n    this.registerHistoryListener = this.registerHistoryListener.bind(this);\n  }\n\n  /**\n   * history@4.x passes separate location and action\n   * params. history@5.x passes location and action\n   * together as a single object.\n   * TODO: If support for React Router <=5 is dropped\n   * this logic is no longer needed. We can just assume\n   * a single object with both location and action.\n   */\n  handleHistoryChange(location: HistoryLocation, action: HistoryAction) {\n    const locationValue = (location as any).location || location;\n    const actionValue = (location as any).action || action;\n    if (this.historyListenHandler) {\n      this.historyListenHandler(locationValue, actionValue);\n    }\n  }\n\n  registerHistoryListener(cb: (location: HistoryLocation, action: HistoryAction) => void) {\n    this.historyListenHandler = cb;\n  }\n\n  render() {\n    const { children, ...props } = this.props;\n    return (\n      <Router history={this.history} {...props}>\n        <IonRouter registerHistoryListener={this.registerHistoryListener}>{children}</IonRouter>\n      </Router>\n    );\n  }\n}\n"],
  "mappings": "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",
  "names": ["MAX_SIGNED_31_BIT_INT", "commonjsGlobal", "globalThis", "window", "global", "getUniqueId", "key", "objectIs", "x", "y", "createEventEmitter", "value", "handlers", "on", "handler", "push", "off", "filter", "h", "get", "set", "newValue", "changedBits", "forEach", "onlyChild", "children", "Array", "isArray", "createReactContext", "defaultValue", "calculateChangedBits", "contextProp", "Provider", "emitter", "props", "getChildContext", "componentWillReceiveProps", "nextProps", "oldValue", "process", "warning", "render", "React", "Component", "childContextTypes", "PropTypes", "object", "isRequired", "Consumer", "observedBits", "state", "getValue", "onUpdate", "setState", "undefined", "componentDidMount", "context", "componentWillUnmount", "contextTypes", "createContext", "createNamedContext", "name", "displayName", "historyContext", "Router", "computeRootMatch", "pathname", "path", "url", "params", "isExact", "location", "history", "_isMounted", "_pendingLocation", "staticContext", "unlisten", "listen", "RouterContext", "match", "HistoryContext", "propTypes", "node", "prototype", "componentDidUpdate", "prevProps", "MemoryRouter", "createHistory", "initialEntries", "array", "initialIndex", "number", "getUserConfirmation", "func", "keyLength", "Lifecycle", "onMount", "call", "onUnmount", "Prompt", "message", "when", "invariant", "method", "block", "self", "release", "messageType", "oneOfType", "string", "bool", "cache", "cacheLimit", "cacheCount", "compilePath", "generator", "pathToRegexp", "compile", "generatePath", "pretty", "Redirect", "computedMatch", "to", "replace", "createLocation", "prevLocation", "locationsAreEqual", "from", "options", "cacheKey", "end", "strict", "sensitive", "pathCache", "keys", "regexp", "result", "matchPath", "exact", "paths", "concat", "reduce", "matched", "exec", "values", "memo", "index", "isEmptyChildren", "Children", "count", "evalChildrenDev", "Route", "component", "createElement", "propName", "isValidElementType", "Error", "arrayOf", "addLeadingSlash", "charAt", "addBasename", "basename", "stripBasename", "base", "indexOf", "substr", "length", "createURL", "createPath", "staticHandler", "methodName", "noop", "StaticRouter", "handlePush", "navigateTo", "handleReplace", "handleListen", "handleBlock", "action", "rest", "createHref", "go", "goBack", "goForward", "Switch", "element", "child", "isValidElement", "cloneElement", "useContext", "React", "window", "global", "key", "buildNames", "cjs", "esm", "umd", "process", "initialBuildName", "secondaryBuildName", "Error", "React", "matchPath", "matchComponent", "createHistory", "Router"]
}
